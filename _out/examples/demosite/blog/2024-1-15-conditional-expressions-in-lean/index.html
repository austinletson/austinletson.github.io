<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Conditional Expressions in Lean — Verso </title><link rel="stylesheet" href="../../static/style.css">
    <style>


.hl.lean {
  white-space: pre;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5em;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .has-info .hover-info.messages {
  max-height: 10em;
  overflow-y: auto;
  overflow-x: hidden;
  padding: 0;
  background-color: #e5e5e5;
}

.hl.lean .hover-info code {
  white-space: pre;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5em;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1em;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0em;
}

@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1em;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: 0.1rem;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5em;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .has-info > .hover-container > .hover-info > code.error {
  background-color: #ffb3b3;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: yellow;
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color: yellow;
  }
}

.hl.lean .has-info .hover-info.messages > code.warning {
  background-color: yellow;
}

.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .has-info .hover-info.messages > code.info {
  background-color: #4777ff;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  width: max-content;
  max-width: 40em;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1em;
  margin-right: 1em;
  margin-top: 0.5em;
  margin-bottom: 0.5em;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2em;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1em;
  padding: 0.5em;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1em;
  height: 0.25em;
  vertical-align: middle;
  width: 0.6em;
  margin-left: 0.1em;
  margin-right: 0.1em;
  display: inline-block;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5em;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5em;
}

.hl.lean .tactic-state details {
  padding-left: 0.5em;
}

.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses td.colon {
  text-align: center;
  min-width: 1em;
}

.hl.lean .tactic-state .hypotheses td.name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses td.name,
.hl.lean .tactic-state .hypotheses td.type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}


</style>
<script>
      
window.onload = () => {
    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
        const str = d.innerText;
        const html = marked.parse(str);
        const rendered = document.createElement("div");
        rendered.classList.add("docstring");
        rendered.innerHTML = html;
        d.parentNode.replaceChild(rendered, d);
    }
}

</script>
    
<script>
      
document.addEventListener("DOMContentLoaded", () => {
    for (const m of document.querySelectorAll(".math.inline")) {
        katex.render(m.textContent, m, {throwOnError: false, displayMode: false});
    }
    for (const m of document.querySelectorAll(".math.display")) {
        katex.render(m.textContent, m, {throwOnError: false, displayMode: true});
    }
});
</script>
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    </head>
  <body>
    <header>
      <div class="inner-wrap">
        <a class="logo" href="../../"><img src="../../static/logo.png"></a><nav class="top" role="navigation">
          <ol>
            <li>
              <a href="../../about">About Me</a></li>
            <li>
              <a href="../../blog">A Verso Blog</a></li>
            </ol>
          </nav>
        </div>
      </header>
    <div class="main" role="main">
      <div class="wrap">
        <h1>
          Conditional Expressions in Lean</h1>
        <div class="metadata">
          <div class="authors">
            <span class="author">Fictional Author</span><span class="author">Another Fictional Author</span></div>
          <div class="date">
            2024-1-15</div>
          <ul class="categories">
            <li>
              <a href="../examples">Examples of Verso usage</a></li>
            <li>
              <a href="../other">Other content</a></li>
            </ul>
          </div>
        <p>
          Finally started blogging!
This post describes the syntax and semantics of conditional expressions in Lean.
Here are some examples:</p>
        <code class="hl lean block" data-lean-context="demo"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-697">example</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-termIfThenElse-708">if<span class="hover-container"><span class="hover-info"><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></span></span></span> <span class="const token" data-binding="const-Bool.true">true<span class="hover-container"><span class="hover-info"><code>Bool.true : Bool</code><span class="sep"></span><code class="docstring">The boolean value `true`, not to be confused with the proposition `True`. </code></span></span></span> <span class="keyword token" data-binding="kw-occ-termIfThenElse-708">then<span class="hover-container"><span class="hover-info"><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></span></span></span> <span class="unknown token" data-binding="">1</span> <span class="keyword token" data-binding="kw-occ-termIfThenElse-708">else<span class="hover-container"><span class="hover-info"><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></span></span></span> <span class="unknown token" data-binding="">2</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-730">example</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-termIfThenElse-741">if<span class="hover-container"><span class="hover-info"><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></span></span></span> <span class="const token" data-binding="const-True">True<span class="hover-container"><span class="hover-info"><code>True : Prop</code><span class="sep"></span><code class="docstring">`True` is a proposition and has only an introduction rule, `True.intro : True`.
In other words, `True` is simply true, and has a canonical proof, `True.intro`
For more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)
</code></span></span></span> <span class="keyword token" data-binding="kw-occ-termIfThenElse-741">then<span class="hover-container"><span class="hover-info"><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></span></span></span> <span class="unknown token" data-binding="">1</span> <span class="keyword token" data-binding="kw-occ-termIfThenElse-741">else<span class="hover-container"><span class="hover-info"><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></span></span></span> <span class="unknown token" data-binding="">2</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-763">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Int">Int<span class="hover-container"><span class="hover-info"><code>Int : Type</code><span class="sep"></span><code class="docstring">The type of integers. It is defined as an inductive type based on the
natural number type `Nat` featuring two constructors: "a natural
number is an integer", and "the negation of a successor of a natural
number is an integer". The former represents integers between `0`
(inclusive) and `∞`, and the latter integers between `-∞` and `-1`
(inclusive).

This type is special-cased by the compiler. The runtime has a special
representation for `Int` which stores "small" signed numbers directly,
and larger numbers use an arbitrary precision "bignum" library
(usually [GMP](https://gmplib.org/)). A "small number" is an integer
that can be encoded with 63 bits (31 bits on 32-bits architectures).
</code></span></span></span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-termIfThenElse-780">if<span class="hover-container"><span class="hover-info"><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></span></span></span> <span class="const token" data-binding="const-True">True<span class="hover-container"><span class="hover-info"><code>True : Prop</code><span class="sep"></span><code class="docstring">`True` is a proposition and has only an introduction rule, `True.intro : True`.
In other words, `True` is simply true, and has a canonical proof, `True.intro`
For more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)
</code></span></span></span> <span class="keyword token" data-binding="kw-occ-termIfThenElse-780">then<span class="hover-container"><span class="hover-info"><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></span></span></span> <span class="unknown token" data-binding="">1</span> <span class="keyword token" data-binding="kw-occ-termIfThenElse-780">else<span class="hover-container"><span class="hover-info"><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></span></span></span> <span class="unknown token" data-binding="">2</span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="demo"><span class="doc-comment token" data-binding="">/-- A recursive function -/</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-848">def</span> <span class="const token" data-binding="const-slowId">slowId<span class="hover-container"><span class="hover-info"><code>_root_.slowId : Nat → Nat</code><span class="sep"></span><code class="docstring">A recursive function </code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat">Nat<span class="hover-container"><span class="hover-info"><code>Nat : Type</code><span class="sep"></span><code class="docstring">The type of natural numbers, starting at zero. It is defined as an
inductive type freely generated by "zero is a natural number" and
"the successor of a natural number is a natural number".

You can prove a theorem `P n` about `n : Nat` by `induction n`, which will
expect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming
a proof of `P i`. The same method also works to define functions by recursion
on natural numbers: induction and recursion are two expressions of the same
operation from Lean's point of view.

```
open Nat
example (n : Nat) : n &lt; succ n := by
  induction n with
  | zero =&gt;
    show 0 &lt; 1
    decide
  | succ i ih =&gt; -- ih : i &lt; succ i
    show succ i &lt; succ (succ i)
    exact Nat.succ_lt_succ ih
```

This type is special-cased by both the kernel and the compiler:
* The type of expressions contains "`Nat` literals" as a primitive constructor,
  and the kernel knows how to reduce zero/succ expressions to nat literals.
* If implemented naively, this type would represent a numeral `n` in unary as a
  linked list with `n` links, which is horribly inefficient. Instead, the
  runtime itself has a special representation for `Nat` which stores numbers up
  to 2^63 directly and larger numbers use an arbitrary precision "bignum"
  library (usually [GMP](https://gmplib.org/)).
</code></span></span></span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Nat">Nat<span class="hover-container"><span class="hover-info"><code>Nat : Type</code><span class="sep"></span><code class="docstring">The type of natural numbers, starting at zero. It is defined as an
inductive type freely generated by "zero is a natural number" and
"the successor of a natural number is a natural number".

You can prove a theorem `P n` about `n : Nat` by `induction n`, which will
expect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming
a proof of `P i`. The same method also works to define functions by recursion
on natural numbers: induction and recursion are two expressions of the same
operation from Lean's point of view.

```
open Nat
example (n : Nat) : n &lt; succ n := by
  induction n with
  | zero =&gt;
    show 0 &lt; 1
    decide
  | succ i ih =&gt; -- ih : i &lt; succ i
    show succ i &lt; succ (succ i)
    exact Nat.succ_lt_succ ih
```

This type is special-cased by both the kernel and the compiler:
* The type of expressions contains "`Nat` literals" as a primitive constructor,
  and the kernel knows how to reduce zero/succ expressions to nat literals.
* If implemented naively, this type would represent a numeral `n` in unary as a
  linked list with `n` links, which is horribly inefficient. Instead, the
  runtime itself has a special representation for `Nat` which stores numbers up
  to 2^63 directly and larger numbers use an arbitrary precision "bignum"
  library (usually [GMP](https://gmplib.org/)).
</code></span></span></span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.294">n<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-slowId">slowId<span class="hover-container"><span class="hover-info"><code>_root_.slowId : Nat → Nat</code><span class="sep"></span><code class="docstring">A recursive function </code></span></span></span> <span class="var token" data-binding="var-_uniq.294">n<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span>

<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">5
</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-911">#eval</span></span> <span class="const token" data-binding="const-slowId">slowId<span class="hover-container"><span class="hover-info"><code>slowId : Nat → Nat</code><span class="sep"></span><code class="docstring">A recursive function </code></span></span></span> <span class="unknown token" data-binding="">5</span>

<span class="doc-comment token" data-binding="">/-- An array literal -/</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-951">example</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">3</span><span class="unknown token" data-binding="">]</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-974">example</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">33</span>
<span class="unknown token" data-binding=""></span></code><p>
          I can also prove things about conditionals!</p>
        <code class="hl lean block" data-lean-context="demo"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-1050">theorem</span> <span class="const token" data-binding="const-lt_4">lt_4<span class="hover-container"><span class="hover-info"><code>_root_.lt_4 (b : Bool) : (if b = true then 1 else 2) &lt; 4</code></span></span></span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.588">b<span class="hover-container"><span class="hover-info"><code>Bool</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Bool">Bool<span class="hover-container"><span class="hover-info"><code>Bool : Type</code><span class="sep"></span><code class="docstring">`Bool` is the type of boolean values, `true` and `false`. Classically,
this is equivalent to `Prop` (the type of propositions), but the distinction
is important for programming, because values of type `Prop` are erased in the
code generator, while `Bool` corresponds to the type called `bool` or `boolean`
in most programming languages.
</code></span></span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">(</span><span class="keyword token" data-binding="kw-occ-termIfThenElse-1077">if<span class="hover-container"><span class="hover-info"><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.588">b<span class="hover-container"><span class="hover-info"><code>Bool</code></span></span></span> <span class="keyword token" data-binding="kw-occ-termIfThenElse-1077">then<span class="hover-container"><span class="hover-info"><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></span></span></span> <span class="unknown token" data-binding="">1</span> <span class="keyword token" data-binding="kw-occ-termIfThenElse-1077">else<span class="hover-container"><span class="hover-info"><code class="docstring">`if c then t else e` is notation for `ite c t e`, "if-then-else", which decides to
return `t` or `e` depending on whether `c` is true or false. The explicit argument
`c : Prop` does not have any actual computational content, but there is an additional
`[Decidable c]` argument synthesized by typeclass inference which actually
determines how to evaluate `c` to true or false. Write `if h : c then t else e`
instead for a "dependent if-then-else" `dite`, which allows `t`/`e` to use the fact
that `c` is true/false.
</code></span></span></span> <span class="unknown token" data-binding="">2</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">&lt;</span> <span class="unknown token" data-binding="">4</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-11618123100196824003-1104-1106"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-1104">by<span class="hover-container"><span class="hover-info"><code class="docstring">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11618123100196824003-1104-1106"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.588">b<span class="hover-container"><span class="hover-info"><code>Bool</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Bool">Bool<span class="hover-container"><span class="hover-info"><code>Bool : Type</code><span class="sep"></span><code class="docstring">`Bool` is the type of boolean values, `true` and `false`. Classically,
this is equivalent to `Prop` (the type of propositions), but the distinction
is important for programming, because values of type `Prop` are erased in the
code generator, while `Bool` corresponds to the type called `bool` or `boolean`
in most programming languages.
</code></span></span></span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">(<span class="keyword token" data-binding="">if</span> <span class="var token" data-binding="var-_uniq.588">b<span class="hover-container"><span class="hover-info"><code>Bool</code></span></span></span><span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-Bool.true">true<span class="hover-container"><span class="hover-info"><code>Bool.true : Bool</code><span class="sep"></span><code class="docstring">The boolean value `true`, not to be confused with the proposition `True`. </code></span></span></span> <span class="keyword token" data-binding="">then</span> 1 <span class="keyword token" data-binding="">else</span> 2)<span class="const token" data-binding="const-LT.lt"> &lt; <span class="hover-container"><span class="hover-info"><code>LT.lt.{u} {α : Type u} [self : LT α] : α → α → Prop</code><span class="sep"></span><code class="docstring">The less-than relation: `x &lt; y` </code></span></span></span>4</span></span></div></div></span>
  <span class="tactic"><label for="tactic-state-14652907523899173528-1109-1114"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.split-1109">split<span class="hover-container"><span class="hover-info"><code class="docstring">The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.
For a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.

For example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate
one goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis
`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly
renamed used the `case` or `next` tactics.

- `split` will split the goal (target).
- `split at h` will split the hypothesis `h`.
</code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14652907523899173528-1109-1114"><div class="tactic-state"><div class="goal"><details open="open"><summary><span class="goal-name">inl</span></summary><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.588">b<span class="hover-container"><span class="hover-info"><code>Bool</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Bool">Bool<span class="hover-container"><span class="hover-info"><code>Bool : Type</code><span class="sep"></span><code class="docstring">`Bool` is the type of boolean values, `true` and `false`. Classically,
this is equivalent to `Prop` (the type of propositions), but the distinction
is important for programming, because values of type `Prop` are erased in the
code generator, while `Bool` corresponds to the type called `bool` or `boolean`
in most programming languages.
</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.814">h✝<span class="hover-container"><span class="hover-info"><code>b = true</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.588">b<span class="hover-container"><span class="hover-info"><code>Bool</code></span></span></span><span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-Bool.true">true<span class="hover-container"><span class="hover-info"><code>Bool.true : Bool</code><span class="sep"></span><code class="docstring">The boolean value `true`, not to be confused with the proposition `True`. </code></span></span></span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-LT.lt"> &lt; <span class="hover-container"><span class="hover-info"><code>LT.lt.{u} {α : Type u} [self : LT α] : α → α → Prop</code><span class="sep"></span><code class="docstring">The less-than relation: `x &lt; y` </code></span></span></span>4</span></span></details></div><div class="goal"><details><summary><span class="goal-name">inr</span></summary><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.588">b<span class="hover-container"><span class="hover-info"><code>Bool</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Bool">Bool<span class="hover-container"><span class="hover-info"><code>Bool : Type</code><span class="sep"></span><code class="docstring">`Bool` is the type of boolean values, `true` and `false`. Classically,
this is equivalent to `Prop` (the type of propositions), but the distinction
is important for programming, because values of type `Prop` are erased in the
code generator, while `Bool` corresponds to the type called `bool` or `boolean`
in most programming languages.
</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.819">h✝<span class="hover-container"><span class="hover-info"><code>¬b = true</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Not">¬<span class="hover-container"><span class="hover-info"><code>Not (a : Prop) : Prop</code><span class="sep"></span><code class="docstring">`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,
so if your goal is `¬p` you can use `intro h` to turn the goal into
`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`
and `(hn h).elim` will prove anything.
For more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)
</code></span></span></span><span class="var token" data-binding="var-_uniq.588">b<span class="hover-container"><span class="hover-info"><code>Bool</code></span></span></span><span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-Bool.true">true<span class="hover-container"><span class="hover-info"><code>Bool.true : Bool</code><span class="sep"></span><code class="docstring">The boolean value `true`, not to be confused with the proposition `True`. </code></span></span></span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">2<span class="const token" data-binding="const-LT.lt"> &lt; <span class="hover-container"><span class="hover-info"><code>LT.lt.{u} {α : Type u} [self : LT α] : α → α → Prop</code><span class="sep"></span><code class="docstring">The less-than relation: `x &lt; y` </code></span></span></span>4</span></span></details></div></div></span>
  <span class="tactic"><label for="tactic-state-4324957916536952032-1117-1118"><span class="unknown token" data-binding="">.</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4324957916536952032-1117-1118"><div class="tactic-state"><div class="goal"><details open="open"><summary><span class="goal-name">inl</span></summary><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.588">b<span class="hover-container"><span class="hover-info"><code>Bool</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Bool">Bool<span class="hover-container"><span class="hover-info"><code>Bool : Type</code><span class="sep"></span><code class="docstring">`Bool` is the type of boolean values, `true` and `false`. Classically,
this is equivalent to `Prop` (the type of propositions), but the distinction
is important for programming, because values of type `Prop` are erased in the
code generator, while `Bool` corresponds to the type called `bool` or `boolean`
in most programming languages.
</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.814">h✝<span class="hover-container"><span class="hover-info"><code>b = true</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.588">b<span class="hover-container"><span class="hover-info"><code>Bool</code></span></span></span><span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-Bool.true">true<span class="hover-container"><span class="hover-info"><code>Bool.true : Bool</code><span class="sep"></span><code class="docstring">The boolean value `true`, not to be confused with the proposition `True`. </code></span></span></span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-LT.lt"> &lt; <span class="hover-container"><span class="hover-info"><code>LT.lt.{u} {α : Type u} [self : LT α] : α → α → Prop</code><span class="sep"></span><code class="docstring">The less-than relation: `x &lt; y` </code></span></span></span>4</span></span></details></div></div></span> <span class="tactic"><label for="tactic-state-4324957916536952032-1119-1123"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-1119">skip<span class="hover-container"><span class="hover-info"><code class="docstring">`skip` does nothing. </code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4324957916536952032-1119-1123"><div class="tactic-state"><div class="goal"><details open="open"><summary><span class="goal-name">inl</span></summary><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.588">b<span class="hover-container"><span class="hover-info"><code>Bool</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Bool">Bool<span class="hover-container"><span class="hover-info"><code>Bool : Type</code><span class="sep"></span><code class="docstring">`Bool` is the type of boolean values, `true` and `false`. Classically,
this is equivalent to `Prop` (the type of propositions), but the distinction
is important for programming, because values of type `Prop` are erased in the
code generator, while `Bool` corresponds to the type called `bool` or `boolean`
in most programming languages.
</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.814">h✝<span class="hover-container"><span class="hover-info"><code>b = true</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.588">b<span class="hover-container"><span class="hover-info"><code>Bool</code></span></span></span><span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-Bool.true">true<span class="hover-container"><span class="hover-info"><code>Bool.true : Bool</code><span class="sep"></span><code class="docstring">The boolean value `true`, not to be confused with the proposition `True`. </code></span></span></span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-LT.lt"> &lt; <span class="hover-container"><span class="hover-info"><code>LT.lt.{u} {α : Type u} [self : LT α] : α → α → Prop</code><span class="sep"></span><code class="docstring">The less-than relation: `x &lt; y` </code></span></span></span>4</span></span></details></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-1125-1131"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-1125">decide<span class="hover-container"><span class="hover-info"><code class="docstring">`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`
and then reducing that instance to evaluate the truth value of `p`.
If it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.

Limitations:
- The target is not allowed to contain local variables or metavariables.
  If there are local variables, you can try first using the `revert` tactic with these local variables
  to move them into the target, which may allow `decide` to succeed.
- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined
  by well-founded recursion might not work, because evaluating them requires reducing proofs.
  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.
  These can appear for instances defined using tactics (such as `rw` and `simp`).
  To avoid this, use definitions such as `decidable_of_iff` instead.

## Examples

Proving inequalities:
```lean
example : 2 + 2 ≠ 5 := by decide
```

Trying to prove a false proposition:
```lean
example : 1 ≠ 1 := by decide
/-
tactic 'decide' proved that the proposition
  1 ≠ 1
is false
-/
```

Trying to prove a proposition whose `Decidable` instance fails to reduce
```lean
opaque unknownProp : Prop

open scoped Classical in
example : unknownProp := by decide
/-
tactic 'decide' failed for proposition
  unknownProp
since its 'Decidable' instance reduced to
  Classical.choice ⋯
rather than to the 'isTrue' constructor.
-/
```

## Properties and relations

For equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.
```lean
example : 1 + 1 = 2 := by decide
example : 1 + 1 = 2 := by rfl
```
</code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-1125-1131"><div class="tactic-state">All goals completed! 🐙</div></span>
  <span class="tactic"><label for="tactic-state-16687016979802746571-1134-1135"><span class="unknown token" data-binding="">.</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-16687016979802746571-1134-1135"><div class="tactic-state"><div class="goal"><details open="open"><summary><span class="goal-name">inr</span></summary><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.588">b<span class="hover-container"><span class="hover-info"><code>Bool</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Bool">Bool<span class="hover-container"><span class="hover-info"><code>Bool : Type</code><span class="sep"></span><code class="docstring">`Bool` is the type of boolean values, `true` and `false`. Classically,
this is equivalent to `Prop` (the type of propositions), but the distinction
is important for programming, because values of type `Prop` are erased in the
code generator, while `Bool` corresponds to the type called `bool` or `boolean`
in most programming languages.
</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.819">h✝<span class="hover-container"><span class="hover-info"><code>¬b = true</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Not">¬<span class="hover-container"><span class="hover-info"><code>Not (a : Prop) : Prop</code><span class="sep"></span><code class="docstring">`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,
so if your goal is `¬p` you can use `intro h` to turn the goal into
`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`
and `(hn h).elim` will prove anything.
For more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)
</code></span></span></span><span class="var token" data-binding="var-_uniq.588">b<span class="hover-container"><span class="hover-info"><code>Bool</code></span></span></span><span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-Bool.true">true<span class="hover-container"><span class="hover-info"><code>Bool.true : Bool</code><span class="sep"></span><code class="docstring">The boolean value `true`, not to be confused with the proposition `True`. </code></span></span></span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">2<span class="const token" data-binding="const-LT.lt"> &lt; <span class="hover-container"><span class="hover-info"><code>LT.lt.{u} {α : Type u} [self : LT α] : α → α → Prop</code><span class="sep"></span><code class="docstring">The less-than relation: `x &lt; y` </code></span></span></span>4</span></span></details></div></div></span> <span class="tactic"><label for="tactic-state-7-1136-1142"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-1136">decide<span class="hover-container"><span class="hover-info"><code class="docstring">`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`
and then reducing that instance to evaluate the truth value of `p`.
If it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.

Limitations:
- The target is not allowed to contain local variables or metavariables.
  If there are local variables, you can try first using the `revert` tactic with these local variables
  to move them into the target, which may allow `decide` to succeed.
- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined
  by well-founded recursion might not work, because evaluating them requires reducing proofs.
  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.
  These can appear for instances defined using tactics (such as `rw` and `simp`).
  To avoid this, use definitions such as `decidable_of_iff` instead.

## Examples

Proving inequalities:
```lean
example : 2 + 2 ≠ 5 := by decide
```

Trying to prove a false proposition:
```lean
example : 1 ≠ 1 := by decide
/-
tactic 'decide' proved that the proposition
  1 ≠ 1
is false
-/
```

Trying to prove a proposition whose `Decidable` instance fails to reduce
```lean
opaque unknownProp : Prop

open scoped Classical in
example : unknownProp := by decide
/-
tactic 'decide' failed for proposition
  unknownProp
since its 'Decidable' instance reduced to
  Classical.choice ⋯
rather than to the 'isTrue' constructor.
-/
```

## Properties and relations

For equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.
```lean
example : 1 + 1 = 2 := by decide
example : 1 + 1 = 2 := by rfl
```
</code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-1136-1142"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code><p>
          It's also nice to write normal proofs sometimes.</p>
        <code class="hl lean block" data-lean-context="demo"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1211">def</span> <span class="const token" data-binding="const-rev">rev<span class="hover-container"><span class="hover-info"><code>rev.{u_1} {α : Type u_1} : List α → List α</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1150">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1150">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.1191">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.1192">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-rev">rev<span class="hover-container"><span class="hover-info"><code>rev.{u_1} {α : Type u_1} : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.1192">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="unknown token" data-binding="">++</span> <span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.1191">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span><span class="unknown token" data-binding="">]</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1284">def</span> <span class="const token" data-binding="const-revAcc">revAcc<span class="hover-container"><span class="hover-info"><code>revAcc.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code></span></span></span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1395">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1392">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1392">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1392">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.1395">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.1435">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.1436">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-revAcc">revAcc<span class="hover-container"><span class="hover-info"><code>revAcc.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code></span></span></span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1435">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.1395">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="unknown token" data-binding="">)</span> <span class="var token" data-binding="var-_uniq.1436">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-1384">theorem</span> <span class="const token" data-binding="const-rev_append_eq_revAcc">rev_append_eq_revAcc<span class="hover-container"><span class="hover-info"><code>rev_append_eq_revAcc.{u_1} {α : Type u_1} (acc xs : List α) : rev xs ++ acc = revAcc acc xs</code></span></span></span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.1634">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.1637">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1631">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
    <span class="const token" data-binding="const-rev">rev<span class="hover-container"><span class="hover-info"><code>rev.{u_1} {α : Type u_1} : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.1637">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="unknown token" data-binding="">++</span> <span class="var token" data-binding="var-_uniq.1634">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="unknown token" data-binding="">=</span> <span class="const token" data-binding="const-revAcc">revAcc<span class="hover-container"><span class="hover-info"><code>revAcc.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.1634">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.1637">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-18107810265512107820-1471-1473"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-1471">by<span class="hover-container"><span class="hover-info"><code class="docstring">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18107810265512107820-1471-1473"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type u_1</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1634">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1637">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-rev">rev<span class="hover-container"><span class="hover-info"><code>rev.{u_1} {α : Type u_1} : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.1637">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-HAppend.hAppend"> ++ <span class="hover-container"><span class="hover-info"><code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class="sep"></span><code class="docstring">`a ++ b` is the result of concatenation of `a` and `b`, usually read "append".
The meaning of this notation is type-dependent. </code></span></span></span><span class="var token" data-binding="var-_uniq.1634">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-revAcc">revAcc<span class="hover-container"><span class="hover-info"><code>revAcc.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.1634">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.1637">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></span></span></div></div></span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.induction-1476">induction<span class="hover-container"><span class="hover-info"><code class="docstring">Assuming `x` is a variable in the local context with an inductive type,
`induction x` applies induction on `x` to the main goal,
producing one goal for each constructor of the inductive type,
in which the target is replaced by a general instance of that constructor
and an inductive hypothesis is added for each recursive argument to the constructor.
If the type of an element in the local context depends on `x`,
that element is reverted and reintroduced afterward,
so that the inductive hypothesis incorporates that hypothesis as well.

For example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,
`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,
and one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.
Here the names `a` and `ih₁` are chosen automatically and are not accessible.
You can use `with` to provide the variables names for each constructor.
- `induction e`, where `e` is an expression instead of a variable,
  generalizes `e` in the goal, and then performs induction on the resulting variable.
- `induction e using r` allows the user to specify the principle of induction that should be used.
  Here `r` should be a term whose result type must be of the form `C t`,
  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables
- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,
  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.
  In other words, the net effect is that each inductive hypothesis is generalized.
- Given `x : Nat`, `induction x with | zero =&gt; tac₁ | succ x' ih =&gt; tac₂`
  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1637">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="keyword token" data-binding="kw-occ-null-1489">generalizing</span> <span class="var token" data-binding="var-_uniq.1634">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.inductionAlts-1506">with<span class="hover-container"><span class="hover-info"><code class="docstring">After `with`, there is an optional tactic that runs on all branches, and
then a list of alternatives.
</code></span></span></span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-List.nil">nil<span class="hover-container"><span class="hover-info"><code>List.nil.{u} {α : Type u} : List α</code><span class="sep"></span><code class="docstring">`[]` is the empty list. </code></span></span></span> <span class="tactic"><label for="tactic-state-11166466468816552015-1519-1521"><span class="unknown token" data-binding="">=&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11166466468816552015-1519-1521"><div class="tactic-state"><div class="goal"><details open="open"><summary><span class="goal-name">nil</span></summary><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type u_1</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1715">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-rev">rev<span class="hover-container"><span class="hover-info"><code>rev.{u_1} {α : Type u_1} : List α → List α</code></span></span></span> []<span class="const token" data-binding="const-HAppend.hAppend"> ++ <span class="hover-container"><span class="hover-info"><code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class="sep"></span><code class="docstring">`a ++ b` is the result of concatenation of `a` and `b`, usually read "append".
The meaning of this notation is type-dependent. </code></span></span></span><span class="var token" data-binding="var-_uniq.1715">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-revAcc">revAcc<span class="hover-container"><span class="hover-info"><code>revAcc.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.1715">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> []</span></span></details></div></div></span> <span class="tactic"><label for="tactic-state-7-1522-1540"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-1522">simp<span class="hover-container"><span class="hover-info"><code class="docstring">The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or
non-dependent hypotheses. It has many variants:
- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.
- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.
  If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with
  `f` are used. This provides a convenient way to unfold `f`.
- `simp [*]` simplifies the main goal target using the lemmas tagged with the
  attribute `[simp]` and all hypotheses.
- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.
- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged
  with the attribute `[simp]`, but removes the ones named `idᵢ`.
- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If
  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis
  `hᵢ` is introduced, but the old one remains in the local context.
- `simp at *` simplifies all the hypotheses and the target.
- `simp [*] at *` simplifies target and all (propositional) hypotheses using the
  other hypotheses.
</code></span></span></span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-rev">rev<span class="hover-container"><span class="hover-info"><code>rev.{u_1} {α : Type u_1} : List α → List α</code></span></span></span><span class="unknown token" data-binding="">,</span> <span class="const token" data-binding="const-revAcc">revAcc<span class="hover-container"><span class="hover-info"><code>revAcc.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code></span></span></span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-1522-1540"><div class="tactic-state">All goals completed! 🐙</div></span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-List.cons">cons<span class="hover-container"><span class="hover-info"><code>List.cons.{u} {α : Type u} (head : α) (tail : List α) : List α</code><span class="sep"></span><code class="docstring">If `a : α` and `l : List α`, then `cons a l`, or `a :: l`, is the
list whose first element is `a` and with `l` as the rest of the list. </code></span></span></span> <span class="var token" data-binding="var-_uniq.2084">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2086">ih<span class="hover-container"><span class="hover-info"><code>∀ (acc : List α), rev xs ++ acc = revAcc acc xs</code></span></span></span> <span class="tactic"><label for="tactic-state-6491050082461044116-1558-1560"><span class="unknown token" data-binding="">=&gt;</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6491050082461044116-1558-1560"><div class="tactic-state"><div class="goal"><details open="open"><summary><span class="goal-name">cons</span></summary><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type u_1</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2084">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2086">ih<span class="hover-container"><span class="hover-info"><code>∀ (acc : List α), rev xs ++ acc = revAcc acc xs</code></span></span></span></td><td class="colon">:</td><td class="type">∀ (<span class="var token" data-binding="var-_uniq.2637">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> : <span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span>), <span class="const token" data-binding="const-rev">rev<span class="hover-container"><span class="hover-info"><code>rev.{u_1} {α : Type u_1} : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-HAppend.hAppend"> ++ <span class="hover-container"><span class="hover-info"><code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class="sep"></span><code class="docstring">`a ++ b` is the result of concatenation of `a` and `b`, usually read "append".
The meaning of this notation is type-dependent. </code></span></span></span><span class="var token" data-binding="var-_uniq.2637">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-revAcc">revAcc<span class="hover-container"><span class="hover-info"><code>revAcc.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2637">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2090">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-rev">rev<span class="hover-container"><span class="hover-info"><code>rev.{u_1} {α : Type u_1} : List α → List α</code></span></span></span> (<span class="var token" data-binding="var-_uniq.2084">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span><span class="const token" data-binding="const-List.cons"> :: <span class="hover-container"><span class="hover-info"><code>List.cons.{u} {α : Type u} (head : α) (tail : List α) : List α</code><span class="sep"></span><code class="docstring">If `a : α` and `l : List α`, then `cons a l`, or `a :: l`, is the
list whose first element is `a` and with `l` as the rest of the list. </code></span></span></span><span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span>)<span class="const token" data-binding="const-HAppend.hAppend"> ++ <span class="hover-container"><span class="hover-info"><code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class="sep"></span><code class="docstring">`a ++ b` is the result of concatenation of `a` and `b`, usually read "append".
The meaning of this notation is type-dependent. </code></span></span></span><span class="var token" data-binding="var-_uniq.2090">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-revAcc">revAcc<span class="hover-container"><span class="hover-info"><code>revAcc.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2090">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> (<span class="var token" data-binding="var-_uniq.2084">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span><span class="const token" data-binding="const-List.cons"> :: <span class="hover-container"><span class="hover-info"><code>List.cons.{u} {α : Type u} (head : α) (tail : List α) : List α</code><span class="sep"></span><code class="docstring">If `a : α` and `l : List α`, then `cons a l`, or `a :: l`, is the
list whose first element is `a` and with `l` as the rest of the list. </code></span></span></span><span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span>)</span></span></details></div></div></span>
    <span class="tactic"><label for="tactic-state-7347946579828091668-1565-1575"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-1565">unfold<span class="hover-container"><span class="hover-info"><code class="docstring">* `unfold id` unfolds definition `id`.
* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.

For non-recursive definitions, this tactic is identical to `delta`.
For definitions by pattern matching, it uses "equation lemmas" which are
autogenerated for each match arm.
</code></span></span></span> <span class="const token" data-binding="const-rev">rev<span class="hover-container"><span class="hover-info"><code>rev.{u_1} {α : Type u_1} : List α → List α</code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7347946579828091668-1565-1575"><div class="tactic-state"><div class="goal"><details open="open"><summary><span class="goal-name">cons</span></summary><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type u_1</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2084">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2086">ih<span class="hover-container"><span class="hover-info"><code>∀ (acc : List α), rev xs ++ acc = revAcc acc xs</code></span></span></span></td><td class="colon">:</td><td class="type">∀ (<span class="var token" data-binding="var-_uniq.2637">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> : <span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span>), <span class="const token" data-binding="const-rev">rev<span class="hover-container"><span class="hover-info"><code>rev.{u_1} {α : Type u_1} : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-HAppend.hAppend"> ++ <span class="hover-container"><span class="hover-info"><code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class="sep"></span><code class="docstring">`a ++ b` is the result of concatenation of `a` and `b`, usually read "append".
The meaning of this notation is type-dependent. </code></span></span></span><span class="var token" data-binding="var-_uniq.2637">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-revAcc">revAcc<span class="hover-container"><span class="hover-info"><code>revAcc.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2637">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2090">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-rev">rev<span class="hover-container"><span class="hover-info"><code>rev.{u_1} {α : Type u_1} : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-HAppend.hAppend"> ++ <span class="hover-container"><span class="hover-info"><code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class="sep"></span><code class="docstring">`a ++ b` is the result of concatenation of `a` and `b`, usually read "append".
The meaning of this notation is type-dependent. </code></span></span></span>[<span class="var token" data-binding="var-_uniq.2084">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span>]<span class="const token" data-binding="const-HAppend.hAppend"> ++ <span class="hover-container"><span class="hover-info"><code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class="sep"></span><code class="docstring">`a ++ b` is the result of concatenation of `a` and `b`, usually read "append".
The meaning of this notation is type-dependent. </code></span></span></span><span class="var token" data-binding="var-_uniq.2090">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-revAcc">revAcc<span class="hover-container"><span class="hover-info"><code>revAcc.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2090">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> (<span class="var token" data-binding="var-_uniq.2084">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span><span class="const token" data-binding="const-List.cons"> :: <span class="hover-container"><span class="hover-info"><code>List.cons.{u} {α : Type u} (head : α) (tail : List α) : List α</code><span class="sep"></span><code class="docstring">If `a : α` and `l : List α`, then `cons a l`, or `a :: l`, is the
list whose first element is `a` and with `l` as the rest of the list. </code></span></span></span><span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span>)</span></span></details></div></div></span>
    <span class="tactic"><label for="tactic-state-10544630031864712558-1580-1593"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-1580">unfold<span class="hover-container"><span class="hover-info"><code class="docstring">* `unfold id` unfolds definition `id`.
* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.

For non-recursive definitions, this tactic is identical to `delta`.
For definitions by pattern matching, it uses "equation lemmas" which are
autogenerated for each match arm.
</code></span></span></span> <span class="const token" data-binding="const-revAcc">revAcc<span class="hover-container"><span class="hover-info"><code>revAcc.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-10544630031864712558-1580-1593"><div class="tactic-state"><div class="goal"><details open="open"><summary><span class="goal-name">cons</span></summary><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type u_1</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2084">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2086">ih<span class="hover-container"><span class="hover-info"><code>∀ (acc : List α), rev xs ++ acc = revAcc acc xs</code></span></span></span></td><td class="colon">:</td><td class="type">∀ (<span class="var token" data-binding="var-_uniq.2637">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> : <span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span>), <span class="const token" data-binding="const-rev">rev<span class="hover-container"><span class="hover-info"><code>rev.{u_1} {α : Type u_1} : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-HAppend.hAppend"> ++ <span class="hover-container"><span class="hover-info"><code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class="sep"></span><code class="docstring">`a ++ b` is the result of concatenation of `a` and `b`, usually read "append".
The meaning of this notation is type-dependent. </code></span></span></span><span class="var token" data-binding="var-_uniq.2637">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-revAcc">revAcc<span class="hover-container"><span class="hover-info"><code>revAcc.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2637">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2090">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-rev">rev<span class="hover-container"><span class="hover-info"><code>rev.{u_1} {α : Type u_1} : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-HAppend.hAppend"> ++ <span class="hover-container"><span class="hover-info"><code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class="sep"></span><code class="docstring">`a ++ b` is the result of concatenation of `a` and `b`, usually read "append".
The meaning of this notation is type-dependent. </code></span></span></span>[<span class="var token" data-binding="var-_uniq.2084">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span>]<span class="const token" data-binding="const-HAppend.hAppend"> ++ <span class="hover-container"><span class="hover-info"><code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class="sep"></span><code class="docstring">`a ++ b` is the result of concatenation of `a` and `b`, usually read "append".
The meaning of this notation is type-dependent. </code></span></span></span><span class="var token" data-binding="var-_uniq.2090">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-revAcc">revAcc<span class="hover-container"><span class="hover-info"><code>revAcc.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code></span></span></span> (<span class="var token" data-binding="var-_uniq.2084">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span><span class="const token" data-binding="const-List.cons"> :: <span class="hover-container"><span class="hover-info"><code>List.cons.{u} {α : Type u} (head : α) (tail : List α) : List α</code><span class="sep"></span><code class="docstring">If `a : α` and `l : List α`, then `cons a l`, or `a :: l`, is the
list whose first element is `a` and with `l` as the rest of the list. </code></span></span></span><span class="var token" data-binding="var-_uniq.2090">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span>) <span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></span></span></details></div></div></span>
    <span class="tactic"><label for="tactic-state-11355170001396843688-1598-1620"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-1598">rw<span class="hover-container"><span class="hover-info"><code class="docstring">`rw` is like `rewrite`, but also tries to close the goal by "cheap" (reducible) `rfl` afterwards.
</code></span></span></span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-List.append_assoc">List.append_assoc<span class="hover-container"><span class="hover-info"><code>List.append_assoc.{u} {α : Type u} (as bs cs : List α) : as ++ bs ++ cs = as ++ (bs ++ cs)</code></span></span></span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11355170001396843688-1598-1620"><div class="tactic-state"><div class="goal"><details open="open"><summary><span class="goal-name">cons</span></summary><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type u_1</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2084">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2086">ih<span class="hover-container"><span class="hover-info"><code>∀ (acc : List α), rev xs ++ acc = revAcc acc xs</code></span></span></span></td><td class="colon">:</td><td class="type">∀ (<span class="var token" data-binding="var-_uniq.2637">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> : <span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span>), <span class="const token" data-binding="const-rev">rev<span class="hover-container"><span class="hover-info"><code>rev.{u_1} {α : Type u_1} : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-HAppend.hAppend"> ++ <span class="hover-container"><span class="hover-info"><code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class="sep"></span><code class="docstring">`a ++ b` is the result of concatenation of `a` and `b`, usually read "append".
The meaning of this notation is type-dependent. </code></span></span></span><span class="var token" data-binding="var-_uniq.2637">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-revAcc">revAcc<span class="hover-container"><span class="hover-info"><code>revAcc.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2637">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.2090">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-List">List<span class="hover-container"><span class="hover-info"><code>List.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`List α` is the type of ordered lists with elements of type `α`.
It is implemented as a linked list.

`List α` is isomorphic to `Array α`, but they are useful for different things:
* `List α` is easier for reasoning, and
  `Array α` is modeled as a wrapper around `List α`
* `List α` works well as a persistent data structure, when many copies of the
  tail are shared. When the value is not shared, `Array α` will have better
  performance because it can do destructive updates.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.1688">α<span class="hover-container"><span class="hover-info"><code>Type u_1</code></span></span></span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-rev">rev<span class="hover-container"><span class="hover-info"><code>rev.{u_1} {α : Type u_1} : List α → List α</code></span></span></span> <span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span><span class="const token" data-binding="const-HAppend.hAppend"> ++ <span class="hover-container"><span class="hover-info"><code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class="sep"></span><code class="docstring">`a ++ b` is the result of concatenation of `a` and `b`, usually read "append".
The meaning of this notation is type-dependent. </code></span></span></span>([<span class="var token" data-binding="var-_uniq.2084">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span>]<span class="const token" data-binding="const-HAppend.hAppend"> ++ <span class="hover-container"><span class="hover-info"><code>HAppend.hAppend.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAppend α β γ] : α → β → γ</code><span class="sep"></span><code class="docstring">`a ++ b` is the result of concatenation of `a` and `b`, usually read "append".
The meaning of this notation is type-dependent. </code></span></span></span><span class="var token" data-binding="var-_uniq.2090">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span>)<span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="const token" data-binding="const-revAcc">revAcc<span class="hover-container"><span class="hover-info"><code>revAcc.{u_1} {α : Type u_1} (acc : List α) : List α → List α</code></span></span></span> (<span class="var token" data-binding="var-_uniq.2084">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span><span class="const token" data-binding="const-List.cons"> :: <span class="hover-container"><span class="hover-info"><code>List.cons.{u} {α : Type u} (head : α) (tail : List α) : List α</code><span class="sep"></span><code class="docstring">If `a : α` and `l : List α`, then `cons a l`, or `a :: l`, is the
list whose first element is `a` and with `l` as the rest of the list. </code></span></span></span><span class="var token" data-binding="var-_uniq.2090">acc<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span>) <span class="var token" data-binding="var-_uniq.2085">xs<span class="hover-container"><span class="hover-info"><code>List α</code></span></span></span></span></span></details></div></div></span>
    <span class="tactic"><label for="tactic-state-7-1625-1633"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-1625">apply<span class="hover-container"><span class="hover-info"><code class="docstring">`apply e` tries to match the current goal against the conclusion of `e`'s type.
If it succeeds, then the tactic returns as many subgoals as the number of premises that
have not been fixed by type inference or type class resolution.
Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution,
and first-order unification with dependent types.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.2086">ih<span class="hover-container"><span class="hover-info"><code>∀ (acc : List α), rev xs ++ acc = revAcc acc xs</code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-1625-1633"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code><p>
          Here are some uses of various constructors:</p>
        <code class="hl lean block" data-lean-context="demo"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1696">def</span> <span class="const token" data-binding="const-squish">squish<span class="hover-container"><span class="hover-info"><code>_root_.squish (n : Option Nat) : Nat</code></span></span></span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2639">n<span class="hover-container"><span class="hover-info"><code>Option Nat</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Option">Option<span class="hover-container"><span class="hover-info"><code>Option.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`Option α` is the type of values which are either `some a` for some `a : α`,
or `none`. In functional programming languages, this type is used to represent
the possibility of failure, or sometimes nullability.

For example, the function `HashMap.find? : HashMap α β → α → Option β` looks up
a specified key `a : α` inside the map. Because we do not know in advance
whether the key is actually in the map, the return type is `Option β`, where
`none` means the value was not in the map, and `some b` means that the value
was found and `b` is the value retrieved.

To extract a value from an `Option α`, we use pattern matching:
```
def map (f : α → β) (x : Option α) : Option β :=
  match x with
  | some a =&gt; some (f a)
  | none =&gt; none
```
We can also use `if let` to pattern match on `Option` and get the value
in the branch:
```
def map (f : α → β) (x : Option α) : Option β :=
  if let some a := x then
    some (f a)
  else
    none
```
</code></span></span></span> <span class="const token" data-binding="const-Nat">Nat<span class="hover-container"><span class="hover-info"><code>Nat : Type</code><span class="sep"></span><code class="docstring">The type of natural numbers, starting at zero. It is defined as an
inductive type freely generated by "zero is a natural number" and
"the successor of a natural number is a natural number".

You can prove a theorem `P n` about `n : Nat` by `induction n`, which will
expect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming
a proof of `P i`. The same method also works to define functions by recursion
on natural numbers: induction and recursion are two expressions of the same
operation from Lean's point of view.

```
open Nat
example (n : Nat) : n &lt; succ n := by
  induction n with
  | zero =&gt;
    show 0 &lt; 1
    decide
  | succ i ih =&gt; -- ih : i &lt; succ i
    show succ i &lt; succ (succ i)
    exact Nat.succ_lt_succ ih
```

This type is special-cased by both the kernel and the compiler:
* The type of expressions contains "`Nat` literals" as a primitive constructor,
  and the kernel knows how to reduce zero/succ expressions to nat literals.
* If implemented naively, this type would represent a numeral `n` in unary as a
  linked list with `n` links, which is horribly inefficient. Instead, the
  runtime itself has a special representation for `Nat` which stores numbers up
  to 2^63 directly and larger numbers use an arbitrary precision "bignum"
  library (usually [GMP](https://gmplib.org/)).
</code></span></span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat">Nat<span class="hover-container"><span class="hover-info"><code>Nat : Type</code><span class="sep"></span><code class="docstring">The type of natural numbers, starting at zero. It is defined as an
inductive type freely generated by "zero is a natural number" and
"the successor of a natural number is a natural number".

You can prove a theorem `P n` about `n : Nat` by `induction n`, which will
expect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming
a proof of `P i`. The same method also works to define functions by recursion
on natural numbers: induction and recursion are two expressions of the same
operation from Lean's point of view.

```
open Nat
example (n : Nat) : n &lt; succ n := by
  induction n with
  | zero =&gt;
    show 0 &lt; 1
    decide
  | succ i ih =&gt; -- ih : i &lt; succ i
    show succ i &lt; succ (succ i)
    exact Nat.succ_lt_succ ih
```

This type is special-cased by both the kernel and the compiler:
* The type of expressions contains "`Nat` literals" as a primitive constructor,
  and the kernel knows how to reduce zero/succ expressions to nat literals.
* If implemented naively, this type would represent a numeral `n` in unary as a
  linked list with `n` links, which is horribly inefficient. Instead, the
  runtime itself has a special representation for `Nat` which stores numbers up
  to 2^63 directly and larger numbers use an arbitrary precision "bignum"
  library (usually [GMP](https://gmplib.org/)).
</code></span></span></span> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-1735">match<span class="hover-container"><span class="hover-info"><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.2639">n<span class="hover-container"><span class="hover-info"><code>Option Nat</code></span></span></span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-1735">with<span class="hover-container"><span class="hover-info"><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></span></span></span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Option.none">none<span class="hover-container"><span class="hover-info"><code>Option.none.{u} {α : Type u} : Option α</code><span class="sep"></span><code class="docstring">No value. </code></span></span></span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Option.some">some<span class="hover-container"><span class="hover-info"><code>Option.some.{u} {α : Type u} (val : α) : Option α</code><span class="sep"></span><code class="docstring">Some value of type `α`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.2675">k<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-Nat.succ">.succ<span class="hover-container"><span class="hover-info"><code>Nat.succ (n : Nat) : Nat</code><span class="sep"></span><code class="docstring">The successor function on natural numbers, `succ n = n + 1`.
This is one of the two constructors of `Nat`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.2675">k<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1785">def</span> <span class="const token" data-binding="const-squish'">squish'<span class="hover-container"><span class="hover-info"><code>_root_.squish' (n : Option Nat) : Nat</code></span></span></span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2734">n<span class="hover-container"><span class="hover-info"><code>Option Nat</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Option">Option<span class="hover-container"><span class="hover-info"><code>Option.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`Option α` is the type of values which are either `some a` for some `a : α`,
or `none`. In functional programming languages, this type is used to represent
the possibility of failure, or sometimes nullability.

For example, the function `HashMap.find? : HashMap α β → α → Option β` looks up
a specified key `a : α` inside the map. Because we do not know in advance
whether the key is actually in the map, the return type is `Option β`, where
`none` means the value was not in the map, and `some b` means that the value
was found and `b` is the value retrieved.

To extract a value from an `Option α`, we use pattern matching:
```
def map (f : α → β) (x : Option α) : Option β :=
  match x with
  | some a =&gt; some (f a)
  | none =&gt; none
```
We can also use `if let` to pattern match on `Option` and get the value
in the branch:
```
def map (f : α → β) (x : Option α) : Option β :=
  if let some a := x then
    some (f a)
  else
    none
```
</code></span></span></span> <span class="const token" data-binding="const-Nat">Nat<span class="hover-container"><span class="hover-info"><code>Nat : Type</code><span class="sep"></span><code class="docstring">The type of natural numbers, starting at zero. It is defined as an
inductive type freely generated by "zero is a natural number" and
"the successor of a natural number is a natural number".

You can prove a theorem `P n` about `n : Nat` by `induction n`, which will
expect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming
a proof of `P i`. The same method also works to define functions by recursion
on natural numbers: induction and recursion are two expressions of the same
operation from Lean's point of view.

```
open Nat
example (n : Nat) : n &lt; succ n := by
  induction n with
  | zero =&gt;
    show 0 &lt; 1
    decide
  | succ i ih =&gt; -- ih : i &lt; succ i
    show succ i &lt; succ (succ i)
    exact Nat.succ_lt_succ ih
```

This type is special-cased by both the kernel and the compiler:
* The type of expressions contains "`Nat` literals" as a primitive constructor,
  and the kernel knows how to reduce zero/succ expressions to nat literals.
* If implemented naively, this type would represent a numeral `n` in unary as a
  linked list with `n` links, which is horribly inefficient. Instead, the
  runtime itself has a special representation for `Nat` which stores numbers up
  to 2^63 directly and larger numbers use an arbitrary precision "bignum"
  library (usually [GMP](https://gmplib.org/)).
</code></span></span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat">Nat<span class="hover-container"><span class="hover-info"><code>Nat : Type</code><span class="sep"></span><code class="docstring">The type of natural numbers, starting at zero. It is defined as an
inductive type freely generated by "zero is a natural number" and
"the successor of a natural number is a natural number".

You can prove a theorem `P n` about `n : Nat` by `induction n`, which will
expect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming
a proof of `P i`. The same method also works to define functions by recursion
on natural numbers: induction and recursion are two expressions of the same
operation from Lean's point of view.

```
open Nat
example (n : Nat) : n &lt; succ n := by
  induction n with
  | zero =&gt;
    show 0 &lt; 1
    decide
  | succ i ih =&gt; -- ih : i &lt; succ i
    show succ i &lt; succ (succ i)
    exact Nat.succ_lt_succ ih
```

This type is special-cased by both the kernel and the compiler:
* The type of expressions contains "`Nat` literals" as a primitive constructor,
  and the kernel knows how to reduce zero/succ expressions to nat literals.
* If implemented naively, this type would represent a numeral `n` in unary as a
  linked list with `n` links, which is horribly inefficient. Instead, the
  runtime itself has a special representation for `Nat` which stores numbers up
  to 2^63 directly and larger numbers use an arbitrary precision "bignum"
  library (usually [GMP](https://gmplib.org/)).
</code></span></span></span> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-1825">match<span class="hover-container"><span class="hover-info"><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.2734">n<span class="hover-container"><span class="hover-info"><code>Option Nat</code></span></span></span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-1825">with<span class="hover-container"><span class="hover-info"><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></span></span></span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Option.none">.none<span class="hover-container"><span class="hover-info"><code>Option.none.{u} {α : Type u} : Option α</code><span class="sep"></span><code class="docstring">No value. </code></span></span></span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Option.some">.some<span class="hover-container"><span class="hover-info"><code>Option.some.{u} {α : Type u} (val : α) : Option α</code><span class="sep"></span><code class="docstring">Some value of type `α`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.2764">k<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.2764">k<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Nat.succ">succ<span class="hover-container"><span class="hover-info"><code>Nat.succ (n : Nat) : Nat</code><span class="sep"></span><code class="docstring">The successor function on natural numbers, `succ n = n + 1`.
This is one of the two constructors of `Nat`. </code></span></span></span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-1876">open<span class="hover-container"><span class="hover-info"><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : α) : α := a
  def K (a : α) : β → α := fun _ =&gt; a
  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I → identity,
      K → konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " ≋ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `≋` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val ≋ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></span></span></span> <span class="unknown token" data-binding="">Nat</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-1876">in</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1888">def</span> <span class="const token" data-binding="const-squish''">squish''<span class="hover-container"><span class="hover-info"><code>_root_.squish'' (n : Option Nat) : Nat</code></span></span></span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2824">n<span class="hover-container"><span class="hover-info"><code>Option Nat</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Option">Option<span class="hover-container"><span class="hover-info"><code>Option.{u} (α : Type u) : Type u</code><span class="sep"></span><code class="docstring">`Option α` is the type of values which are either `some a` for some `a : α`,
or `none`. In functional programming languages, this type is used to represent
the possibility of failure, or sometimes nullability.

For example, the function `HashMap.find? : HashMap α β → α → Option β` looks up
a specified key `a : α` inside the map. Because we do not know in advance
whether the key is actually in the map, the return type is `Option β`, where
`none` means the value was not in the map, and `some b` means that the value
was found and `b` is the value retrieved.

To extract a value from an `Option α`, we use pattern matching:
```
def map (f : α → β) (x : Option α) : Option β :=
  match x with
  | some a =&gt; some (f a)
  | none =&gt; none
```
We can also use `if let` to pattern match on `Option` and get the value
in the branch:
```
def map (f : α → β) (x : Option α) : Option β :=
  if let some a := x then
    some (f a)
  else
    none
```
</code></span></span></span> <span class="const token" data-binding="const-Nat">Nat<span class="hover-container"><span class="hover-info"><code>Nat : Type</code><span class="sep"></span><code class="docstring">The type of natural numbers, starting at zero. It is defined as an
inductive type freely generated by "zero is a natural number" and
"the successor of a natural number is a natural number".

You can prove a theorem `P n` about `n : Nat` by `induction n`, which will
expect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming
a proof of `P i`. The same method also works to define functions by recursion
on natural numbers: induction and recursion are two expressions of the same
operation from Lean's point of view.

```
open Nat
example (n : Nat) : n &lt; succ n := by
  induction n with
  | zero =&gt;
    show 0 &lt; 1
    decide
  | succ i ih =&gt; -- ih : i &lt; succ i
    show succ i &lt; succ (succ i)
    exact Nat.succ_lt_succ ih
```

This type is special-cased by both the kernel and the compiler:
* The type of expressions contains "`Nat` literals" as a primitive constructor,
  and the kernel knows how to reduce zero/succ expressions to nat literals.
* If implemented naively, this type would represent a numeral `n` in unary as a
  linked list with `n` links, which is horribly inefficient. Instead, the
  runtime itself has a special representation for `Nat` which stores numbers up
  to 2^63 directly and larger numbers use an arbitrary precision "bignum"
  library (usually [GMP](https://gmplib.org/)).
</code></span></span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat">Nat<span class="hover-container"><span class="hover-info"><code>Nat : Type</code><span class="sep"></span><code class="docstring">The type of natural numbers, starting at zero. It is defined as an
inductive type freely generated by "zero is a natural number" and
"the successor of a natural number is a natural number".

You can prove a theorem `P n` about `n : Nat` by `induction n`, which will
expect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming
a proof of `P i`. The same method also works to define functions by recursion
on natural numbers: induction and recursion are two expressions of the same
operation from Lean's point of view.

```
open Nat
example (n : Nat) : n &lt; succ n := by
  induction n with
  | zero =&gt;
    show 0 &lt; 1
    decide
  | succ i ih =&gt; -- ih : i &lt; succ i
    show succ i &lt; succ (succ i)
    exact Nat.succ_lt_succ ih
```

This type is special-cased by both the kernel and the compiler:
* The type of expressions contains "`Nat` literals" as a primitive constructor,
  and the kernel knows how to reduce zero/succ expressions to nat literals.
* If implemented naively, this type would represent a numeral `n` in unary as a
  linked list with `n` links, which is horribly inefficient. Instead, the
  runtime itself has a special representation for `Nat` which stores numbers up
  to 2^63 directly and larger numbers use an arbitrary precision "bignum"
  library (usually [GMP](https://gmplib.org/)).
</code></span></span></span> <span class="unknown token" data-binding="">:=</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-1929">match<span class="hover-container"><span class="hover-info"><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.2824">n<span class="hover-container"><span class="hover-info"><code>Option Nat</code></span></span></span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.match-1929">with<span class="hover-container"><span class="hover-info"><code class="docstring">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given
term `e` against each pattern `p` of a match alternative. When all patterns
of an alternative match, the `match` term evaluates to the value of the
corresponding right-hand side `f` with the pattern variables bound to the
respective matched values.
If used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available
within `f`.

When not constructing a proof, `match` does not automatically substitute variables
matched on in dependent variables' types. Use `match (generalizing := true) ...` to
enforce this.

Syntax quotations can also be used in a pattern match.
This matches a `Syntax` value against quotations, pattern variables, or `_`.

Quoted identifiers only match identical identifiers - custom matching such as by the preresolved
names only should be done explicitly.

`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.
For users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they
should participate in matching.
For example, in
```lean
syntax "c" ("foo" &lt;|&gt; "bar") ...
```
`foo` and `bar` are indistinguishable during matching, but in
```lean
syntax foo := "foo"
syntax "c" (foo &lt;|&gt; "bar") ...
```
they are not.
</code></span></span></span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Option.none">none<span class="hover-container"><span class="hover-info"><code>Option.none.{u} {α : Type u} : Option α</code><span class="sep"></span><code class="docstring">No value. </code></span></span></span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">0</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Option.some">some<span class="hover-container"><span class="hover-info"><code>Option.some.{u} {α : Type u} (val : α) : Option α</code><span class="sep"></span><code class="docstring">Some value of type `α`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.2860">k<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-Nat.succ">succ<span class="hover-container"><span class="hover-info"><code>Nat.succ (n : Nat) : Nat</code><span class="sep"></span><code class="docstring">The successor function on natural numbers, `succ n = n + 1`.
This is one of the two constructors of `Nat`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.2860">k<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span>

<span class="unknown token" data-binding=""></span></code><p>
          Here is a mutual block:</p>
        <code class="hl lean block" data-lean-context="demo"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-2020">mutual</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2029">def</span> <span class="const token" data-binding="const-f">f<span class="hover-container"><span class="hover-info"><code>_root_.f : Nat → Nat</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat">Nat<span class="hover-container"><span class="hover-info"><code>Nat : Type</code><span class="sep"></span><code class="docstring">The type of natural numbers, starting at zero. It is defined as an
inductive type freely generated by "zero is a natural number" and
"the successor of a natural number is a natural number".

You can prove a theorem `P n` about `n : Nat` by `induction n`, which will
expect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming
a proof of `P i`. The same method also works to define functions by recursion
on natural numbers: induction and recursion are two expressions of the same
operation from Lean's point of view.

```
open Nat
example (n : Nat) : n &lt; succ n := by
  induction n with
  | zero =&gt;
    show 0 &lt; 1
    decide
  | succ i ih =&gt; -- ih : i &lt; succ i
    show succ i &lt; succ (succ i)
    exact Nat.succ_lt_succ ih
```

This type is special-cased by both the kernel and the compiler:
* The type of expressions contains "`Nat` literals" as a primitive constructor,
  and the kernel knows how to reduce zero/succ expressions to nat literals.
* If implemented naively, this type would represent a numeral `n` in unary as a
  linked list with `n` links, which is horribly inefficient. Instead, the
  runtime itself has a special representation for `Nat` which stores numbers up
  to 2^63 directly and larger numbers use an arbitrary precision "bignum"
  library (usually [GMP](https://gmplib.org/)).
</code></span></span></span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Nat">Nat<span class="hover-container"><span class="hover-info"><code>Nat : Type</code><span class="sep"></span><code class="docstring">The type of natural numbers, starting at zero. It is defined as an
inductive type freely generated by "zero is a natural number" and
"the successor of a natural number is a natural number".

You can prove a theorem `P n` about `n : Nat` by `induction n`, which will
expect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming
a proof of `P i`. The same method also works to define functions by recursion
on natural numbers: induction and recursion are two expressions of the same
operation from Lean's point of view.

```
open Nat
example (n : Nat) : n &lt; succ n := by
  induction n with
  | zero =&gt;
    show 0 &lt; 1
    decide
  | succ i ih =&gt; -- ih : i &lt; succ i
    show succ i &lt; succ (succ i)
    exact Nat.succ_lt_succ ih
```

This type is special-cased by both the kernel and the compiler:
* The type of expressions contains "`Nat` literals" as a primitive constructor,
  and the kernel knows how to reduce zero/succ expressions to nat literals.
* If implemented naively, this type would represent a numeral `n` in unary as a
  linked list with `n` links, which is horribly inefficient. Instead, the
  runtime itself has a special representation for `Nat` which stores numbers up
  to 2^63 directly and larger numbers use an arbitrary precision "bignum"
  library (usually [GMP](https://gmplib.org/)).
</code></span></span></span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">1</span>
    <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.3012">n<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-g">g<span class="hover-container"><span class="hover-info"><code>_root_.g : Nat → Nat</code></span></span></span> <span class="var token" data-binding="var-_uniq.3012">n<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span>

  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2084">def</span> <span class="const token" data-binding="const-g">g<span class="hover-container"><span class="hover-info"><code>_root_.g : Nat → Nat</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat">Nat<span class="hover-container"><span class="hover-info"><code>Nat : Type</code><span class="sep"></span><code class="docstring">The type of natural numbers, starting at zero. It is defined as an
inductive type freely generated by "zero is a natural number" and
"the successor of a natural number is a natural number".

You can prove a theorem `P n` about `n : Nat` by `induction n`, which will
expect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming
a proof of `P i`. The same method also works to define functions by recursion
on natural numbers: induction and recursion are two expressions of the same
operation from Lean's point of view.

```
open Nat
example (n : Nat) : n &lt; succ n := by
  induction n with
  | zero =&gt;
    show 0 &lt; 1
    decide
  | succ i ih =&gt; -- ih : i &lt; succ i
    show succ i &lt; succ (succ i)
    exact Nat.succ_lt_succ ih
```

This type is special-cased by both the kernel and the compiler:
* The type of expressions contains "`Nat` literals" as a primitive constructor,
  and the kernel knows how to reduce zero/succ expressions to nat literals.
* If implemented naively, this type would represent a numeral `n` in unary as a
  linked list with `n` links, which is horribly inefficient. Instead, the
  runtime itself has a special representation for `Nat` which stores numbers up
  to 2^63 directly and larger numbers use an arbitrary precision "bignum"
  library (usually [GMP](https://gmplib.org/)).
</code></span></span></span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Nat">Nat<span class="hover-container"><span class="hover-info"><code>Nat : Type</code><span class="sep"></span><code class="docstring">The type of natural numbers, starting at zero. It is defined as an
inductive type freely generated by "zero is a natural number" and
"the successor of a natural number is a natural number".

You can prove a theorem `P n` about `n : Nat` by `induction n`, which will
expect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming
a proof of `P i`. The same method also works to define functions by recursion
on natural numbers: induction and recursion are two expressions of the same
operation from Lean's point of view.

```
open Nat
example (n : Nat) : n &lt; succ n := by
  induction n with
  | zero =&gt;
    show 0 &lt; 1
    decide
  | succ i ih =&gt; -- ih : i &lt; succ i
    show succ i &lt; succ (succ i)
    exact Nat.succ_lt_succ ih
```

This type is special-cased by both the kernel and the compiler:
* The type of expressions contains "`Nat` literals" as a primitive constructor,
  and the kernel knows how to reduce zero/succ expressions to nat literals.
* If implemented naively, this type would represent a numeral `n` in unary as a
  linked list with `n` links, which is horribly inefficient. Instead, the
  runtime itself has a special representation for `Nat` which stores numbers up
  to 2^63 directly and larger numbers use an arbitrary precision "bignum"
  library (usually [GMP](https://gmplib.org/)).
</code></span></span></span>
    <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">0</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="unknown token" data-binding="">0</span>
    <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.3126">n<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-f">f<span class="hover-container"><span class="hover-info"><code>_root_.f : Nat → Nat</code></span></span></span> <span class="var token" data-binding="var-_uniq.3126">n<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.mutual-2020">end</span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="demo"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-2166">example</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">99</span>
<span class="unknown token" data-binding=""></span></code><p>
          Here is a proof with some lambdas and big terms in it, to check highlighting:</p>
        <code class="hl lean block" data-lean-context="demo"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2277">def</span> <span class="const token" data-binding="const-grow">grow<span class="hover-container"><span class="hover-info"><code>grow.{u_1} {α : Sort u_1} : Nat → α → α</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Nat">Nat<span class="hover-container"><span class="hover-info"><code>Nat : Type</code><span class="sep"></span><code class="docstring">The type of natural numbers, starting at zero. It is defined as an
inductive type freely generated by "zero is a natural number" and
"the successor of a natural number is a natural number".

You can prove a theorem `P n` about `n : Nat` by `induction n`, which will
expect a proof of the theorem for `P 0`, and a proof of `P (succ i)` assuming
a proof of `P i`. The same method also works to define functions by recursion
on natural numbers: induction and recursion are two expressions of the same
operation from Lean's point of view.

```
open Nat
example (n : Nat) : n &lt; succ n := by
  induction n with
  | zero =&gt;
    show 0 &lt; 1
    decide
  | succ i ih =&gt; -- ih : i &lt; succ i
    show succ i &lt; succ (succ i)
    exact Nat.succ_lt_succ ih
```

This type is special-cased by both the kernel and the compiler:
* The type of expressions contains "`Nat` literals" as a primitive constructor,
  and the kernel knows how to reduce zero/succ expressions to nat literals.
* If implemented naively, this type would represent a numeral `n` in unary as a
  linked list with `n` links, which is horribly inefficient. Instead, the
  runtime itself has a special representation for `Nat` which stores numbers up
  to 2^63 directly and larger numbers use an arbitrary precision "bignum"
  library (usually [GMP](https://gmplib.org/)).
</code></span></span></span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.4378">α<span class="hover-container"><span class="hover-info"><code>Sort u_1</code></span></span></span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.4378">α<span class="hover-container"><span class="hover-info"><code>Sort u_1</code></span></span></span>
  <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">0</span> <span class="unknown token" data-binding="">|</span> <span class="unknown token" data-binding="">1</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-2319">fun</span> <span class="var token" data-binding="var-_uniq.4407">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.4407">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span>
  <span class="unknown token" data-binding="">|</span> <span class="var token" data-binding="var-_uniq.4497">n<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">2</span> <span class="unknown token" data-binding="">=&gt;</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-2347">let<span class="hover-container"><span class="hover-info"><code class="docstring">`let` is used to declare a local definition. Example:
```
let x := 1
let y := x + 1
x + y
```
Since functions are first class citizens in Lean, you can use `let` to declare
local functions too.
```
let double := fun x =&gt; 2*x
double (double 3)
```
For recursive definitions, you should use `let rec`.
You can also perform pattern matching using `let`. For example,
assume `p` has type `Nat × Nat`, then you can write
```
let (x, y) := p
x + y
```
</code></span></span></span> <span class="var token" data-binding="var-_uniq.4504">f1<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> <span class="unknown token" data-binding="">:=</span> <span class="const token" data-binding="const-grow">grow<span class="hover-container"><span class="hover-info"><code>grow.{u_1} {α : Sort u_1} : Nat → α → α</code></span></span></span> <span class="var token" data-binding="var-_uniq.4497">n<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.let-2368">let<span class="hover-container"><span class="hover-info"><code class="docstring">`let` is used to declare a local definition. Example:
```
let x := 1
let y := x + 1
x + y
```
Since functions are first class citizens in Lean, you can use `let` to declare
local functions too.
```
let double := fun x =&gt; 2*x
double (double 3)
```
For recursive definitions, you should use `let rec`.
You can also perform pattern matching using `let`. For example,
assume `p` has type `Nat × Nat`, then you can write
```
let (x, y) := p
x + y
```
</code></span></span></span> <span class="var token" data-binding="var-_uniq.4544">f2<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span> <span class="unknown token" data-binding="">:=</span> <span class="const token" data-binding="const-grow">grow<span class="hover-container"><span class="hover-info"><code>grow.{u_1} {α : Sort u_1} : Nat → α → α</code></span></span></span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4497">n<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span> <span class="unknown token" data-binding="">+</span> <span class="unknown token" data-binding="">1</span><span class="unknown token" data-binding="">)</span>
    <span class="var token" data-binding="var-_uniq.4504">f1<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> <span class="var token" data-binding="var-_uniq.4544">f2<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.theorem-2402">theorem</span> <span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="const token" data-binding="const-grow_10_id">grow_10_id<span class="hover-container"><span class="hover-info"><code>grow_10_id.{u_1} {α : Sort u_1} : grow 6 = id</code></span></span></span></span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.4847">α<span class="hover-container"><span class="hover-info"><code>Sort u_1</code></span></span></span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-grow">grow<span class="hover-container"><span class="hover-info"><code>grow.{u_1} {α : Sort u_1} : Nat → α → α</code></span></span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">α</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.4847">α<span class="hover-container"><span class="hover-info"><code>Sort u_1</code></span></span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">6</span> <span class="unknown token" data-binding="">=</span> <span class="const token" data-binding="const-id">id<span class="hover-container"><span class="hover-info"><code>id.{u} {α : Sort u} (a : α) : α</code><span class="sep"></span><code class="docstring">The identity function. `id` takes an implicit argument `α : Sort u`
(a type in any universe), and an argument `a : α`, and returns `a`.

Although this may look like a useless function, one application of the identity
function is to explicitly put a type on an expression. If `e` has type `T`,
and `T'` is definitionally equal to `T`, then `@id T' e` typechecks, and Lean
knows that this expression has type `T'` rather than `T`. This can make a
difference for typeclass inference, since `T` and `T'` may have different
typeclass instances on them. `show T' from e` is sugar for an `@id T' e`
expression.
</code></span></span></span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-13072912647616505704-2454-2456"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-2454">by<span class="hover-container"><span class="hover-info"><code class="docstring">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13072912647616505704-2454-2456"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4847">α<span class="hover-container"><span class="hover-info"><code>Sort u_1</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Sort u_1</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-grow">grow<span class="hover-container"><span class="hover-info"><code>grow.{u_1} {α : Sort u_1} : Nat → α → α</code></span></span></span> 6<span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span>id</span></span></div></div></span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticRepeat_-2459">repeat<span class="hover-container"><span class="hover-info"><code class="docstring">`repeat tac` repeatedly applies `tac` to the main goal until it fails.
That is, if `tac` produces multiple subgoals, only subgoals up to the first failure will be visited.
The `Std` library provides `repeat'` which repeats separately in each subgoal.
</code></span></span></span> <span class="tactic"><label for="tactic-state-14346316352744530207-2466-2477"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-2466">unfold<span class="hover-container"><span class="hover-info"><code class="docstring">* `unfold id` unfolds definition `id`.
* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.

For non-recursive definitions, this tactic is identical to `delta`.
For definitions by pattern matching, it uses "equation lemmas" which are
autogenerated for each match arm.
</code></span></span></span> <span class="const token" data-binding="const-grow">grow<span class="hover-container"><span class="hover-info"><code>grow.{u_1} {α : Sort u_1} : Nat → α → α</code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14346316352744530207-2466-2477"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.4847">α<span class="hover-container"><span class="hover-info"><code>Sort u_1</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Sort u_1</span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">(<span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8382">f1<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> :=
    <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8353">f1<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span> :=
      <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8342">f1<span class="hover-container"><span class="hover-info"><code>(((α → α) → α → α) → (α → α) → α → α) → ((α → α) → α → α) → (α → α) → α → α</code></span></span></span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.8331">x<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span> =&gt; <span class="var token" data-binding="var-_uniq.8331">x<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span>;
      <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8349">f2<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.8344">x<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> =&gt; <span class="var token" data-binding="var-_uniq.8344">x<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span>;
      <span class="var token" data-binding="var-_uniq.8342">f1<span class="hover-container"><span class="hover-info"><code>(((α → α) → α → α) → (α → α) → α → α) → ((α → α) → α → α) → (α → α) → α → α</code></span></span></span> <span class="var token" data-binding="var-_uniq.8349">f2<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span>;
    <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8379">f2<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> :=
      <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8361">f1<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.8356">x<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> =&gt; <span class="var token" data-binding="var-_uniq.8356">x<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span>;
      <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8376">f2<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> :=
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8369">f1<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.8364">x<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> =&gt; <span class="var token" data-binding="var-_uniq.8364">x<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span>;
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8373">f2<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.8371">x<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span> =&gt; <span class="var token" data-binding="var-_uniq.8371">x<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span>;
        <span class="var token" data-binding="var-_uniq.8369">f1<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span> <span class="var token" data-binding="var-_uniq.8373">f2<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span>;
      <span class="var token" data-binding="var-_uniq.8361">f1<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span> <span class="var token" data-binding="var-_uniq.8376">f2<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span>;
    <span class="var token" data-binding="var-_uniq.8353">f1<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span> <span class="var token" data-binding="var-_uniq.8379">f2<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span>;
  <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8440">f2<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span> :=
    <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8405">f1<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> :=
      <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8390">f1<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.8385">x<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> =&gt; <span class="var token" data-binding="var-_uniq.8385">x<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span>;
      <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8402">f2<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> :=
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8396">f1<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.8391">x<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> =&gt; <span class="var token" data-binding="var-_uniq.8391">x<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span>;
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8399">f2<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.8397">x<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span> =&gt; <span class="var token" data-binding="var-_uniq.8397">x<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span>;
        <span class="var token" data-binding="var-_uniq.8396">f1<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span> <span class="var token" data-binding="var-_uniq.8399">f2<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span>;
      <span class="var token" data-binding="var-_uniq.8390">f1<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span> <span class="var token" data-binding="var-_uniq.8402">f2<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span>;
    <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8438">f2<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span> :=
      <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8419">f1<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> :=
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8413">f1<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.8408">x<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> =&gt; <span class="var token" data-binding="var-_uniq.8408">x<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span>;
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8416">f2<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.8414">x<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span> =&gt; <span class="var token" data-binding="var-_uniq.8414">x<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span>;
        <span class="var token" data-binding="var-_uniq.8413">f1<span class="hover-container"><span class="hover-info"><code>((α → α) → α → α) → (α → α) → α → α</code></span></span></span> <span class="var token" data-binding="var-_uniq.8416">f2<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span>;
      <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8436">f2<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span> :=
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8424">f1<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.8422">x<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span> =&gt; <span class="var token" data-binding="var-_uniq.8422">x<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span>;
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8434">f2<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span> :=
          <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8429">f1<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.8427">x<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span> =&gt; <span class="var token" data-binding="var-_uniq.8427">x<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span>;
          <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.8432">f2<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span> := <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.8431">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span> =&gt; <span class="var token" data-binding="var-_uniq.8431">x<span class="hover-container"><span class="hover-info"><code>α</code></span></span></span>;
          <span class="var token" data-binding="var-_uniq.8429">f1<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> <span class="var token" data-binding="var-_uniq.8432">f2<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span>;
        <span class="var token" data-binding="var-_uniq.8424">f1<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> <span class="var token" data-binding="var-_uniq.8434">f2<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span>;
      <span class="var token" data-binding="var-_uniq.8419">f1<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> <span class="var token" data-binding="var-_uniq.8436">f2<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span>;
    <span class="var token" data-binding="var-_uniq.8405">f1<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> <span class="var token" data-binding="var-_uniq.8438">f2<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span>;
  <span class="var token" data-binding="var-_uniq.8382">f1<span class="hover-container"><span class="hover-info"><code>(α → α) → α → α</code></span></span></span> <span class="var token" data-binding="var-_uniq.8440">f2<span class="hover-container"><span class="hover-info"><code>α → α</code></span></span></span>)<span class="const token" data-binding="const-Eq"> =
  <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span>id</span></span></div></div></span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.allGoals-2480">all_goals<span class="hover-container"><span class="hover-info"><code class="docstring">`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. </code></span></span></span> <span class="tactic"><label for="tactic-state-7-2490-2495"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-2490">sorry<span class="hover-container"><span class="hover-info"><code class="docstring">The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete
parts of a proof while still having a syntactically correct proof skeleton. Lean will give
a warning whenever a proof uses `sorry`, so you aren't likely to miss it, but
you can double check if a theorem depends on `sorry` by using
`#print axioms my_thm` and looking for `sorryAx` in the axiom list.
</code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-2490-2495"><div class="tactic-state">All goals completed! 🐙</div></span>

<span class="unknown token" data-binding=""></span></code><p>
          Here is a proof with big terms in the context:</p>
        <code class="hl lean block" data-lean-context="demo"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-2563">open<span class="hover-container"><span class="hover-info"><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : α) : α := a
  def K (a : α) : β → α := fun _ =&gt; a
  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I → identity,
      K → konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " ≋ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `≋` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val ≋ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></span></span></span> <span class="unknown token" data-binding="">Lean</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-2563">in</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2576">def</span> <span class="const token" data-binding="const-quotedStx">quotedStx<span class="hover-container"><span class="hover-info"><code>_root_.quotedStx {m : Type → Type} [Monad m] [MonadQuotation m] [MonadRef m] (str : String) : m Syntax</code></span></span></span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Monad">Monad<span class="hover-container"><span class="hover-info"><code>Monad.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class="sep"></span><code class="docstring">A [monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)) is a
structure which abstracts the concept of sequential control flow.
It mainly consists of two operations:

* `pure : α → F α`
* `bind : F α → (α → F β) → F β` (written as `&gt;&gt;=`)

Like many functional programming languages, Lean makes extensive use of monads
for structuring programs. In particular, the `do` notation is a very powerful
syntax over monad operations, and it depends on a `Monad` instance.

See [the `do` notation](https://lean-lang.org/lean4/doc/do.html)
chapter of the manual for details.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.8329">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Lean.MonadQuotation">MonadQuotation<span class="hover-container"><span class="hover-info"><code>Lean.MonadQuotation (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A monad that supports syntax quotations. Syntax quotations (in term
position) are monadic values that when executed retrieve the current "macro
scope" from the monad and apply it to every identifier they introduce
(independent of whether this identifier turns out to be a reference to an
existing declaration, or an actually fresh binding during further
elaboration). We also apply the position of the result of `getRef` to each
introduced symbol, which results in better error positions than not applying
any position. </code></span></span></span> <span class="var token" data-binding="var-_uniq.8329">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Lean.MonadRef">MonadRef<span class="hover-container"><span class="hover-info"><code>Lean.MonadRef (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A `MonadRef` is a monad that has a `ref : Syntax` in the read-only state.
This is used to keep track of the location where we are working; if an exception
is thrown, the `ref` gives the location where the error will be reported,
assuming no more specific location is provided.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.8329">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8343">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-String">String<span class="hover-container"><span class="hover-info"><code>String : Type</code><span class="sep"></span><code class="docstring">`String` is the type of (UTF-8 encoded) strings.

The compiler overrides the data representation of this type to a byte sequence,
and both `String.utf8ByteSize` and `String.length` are cached and O(1).
</code></span></span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.8329">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span> <span class="const token" data-binding="const-Lean.Syntax">Syntax<span class="hover-container"><span class="hover-info"><code>Lean.Syntax : Type</code><span class="sep"></span><code class="docstring">Syntax objects used by the parser, macro expander, delaborator, etc.
</code></span></span></span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-2661">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-2666">let</span> <span class="var token" data-binding="var-_uniq.8777">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span> <span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">a</span> <span class="unknown token" data-binding="">b</span> <span class="unknown token" data-binding="">c</span> <span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">$</span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Quote.quote">quote<span class="hover-container"><span class="hover-info"><code>Lean.Quote.quote {α : Type} {k : optParam SyntaxNodeKind `term} [self : Quote α k] : α → TSyntax k</code></span></span></span> <span class="var token" data-binding="var-_uniq.8343">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">z</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span>
  <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.8777">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-2717">open<span class="hover-container"><span class="hover-info"><code class="docstring">Makes names from other namespaces visible without writing the namespace prefix.

Names that are made available with `open` are visible within the current `section` or `namespace`
block. This makes referring to (type) definitions and theorems easier, but note that it can also
make [scoped instances], notations, and attributes from a different namespace available.

The `open` command can be used in a few different ways:

* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in
  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that
  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and
  `y`.

* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`
  except `def1` and `def2`.

* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and
  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would
  be unaffected.

  This works even if `def1` and `def2` are `protected`.

* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path
  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.

  This works even if `def1` and `def2` are `protected`.

* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],
  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name
  available.

* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next
  command or expression.

[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances
(Scoped instances in Theorem Proving in Lean)


## Examples

```lean
/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/
namespace Combinator.Calculus
  def I (a : α) : α := a
  def K (a : α) : β → α := fun _ =&gt; a
  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)
end Combinator.Calculus

section
  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,
  -- until the section ends
  open Combinator.Calculus

  theorem SKx_eq_K : S K x = I := rfl
end

-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)
open Combinator.Calculus in
theorem SKx_eq_K' : S K x = I := rfl

section
  -- open only `S` and `K` under `Combinator.Calculus`
  open Combinator.Calculus (S K)

  theorem SKxy_eq_y : S K x y = y := rfl

  -- `I` is not in scope, we have to use its full path
  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl
end

section
  open Combinator.Calculus
    renaming
      I → identity,
      K → konstant

  #check identity
  #check konstant
end

section
  open Combinator.Calculus
    hiding S

  #check I
  #check K
end

section
  namespace Demo
    inductive MyType
    | val

    namespace N1
      scoped infix:68 " ≋ " =&gt; BEq.beq

      scoped instance : BEq MyType where
        beq _ _ := true

      def Alias := MyType
    end N1
  end Demo

  -- bring `≋` and the instance in scope, but not `Alias`
  open scoped Demo.N1

  #check Demo.MyType.val == Demo.MyType.val
  #check Demo.MyType.val ≋ Demo.MyType.val
  -- #check Alias -- unknown identifier 'Alias'
end
```
</code></span></span></span> <span class="unknown token" data-binding="">Lean</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.in-2717">in</span>
<span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-2730">example</span></span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Monad">Monad<span class="hover-container"><span class="hover-info"><code>Monad.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class="sep"></span><code class="docstring">A [monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)) is a
structure which abstracts the concept of sequential control flow.
It mainly consists of two operations:

* `pure : α → F α`
* `bind : F α → (α → F β) → F β` (written as `&gt;&gt;=`)

Like many functional programming languages, Lean makes extensive use of monads
for structuring programs. In particular, the `do` notation is a very powerful
syntax over monad operations, and it depends on a `Monad` instance.

See [the `do` notation](https://lean-lang.org/lean4/doc/do.html)
chapter of the manual for details.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.8919">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Lean.MonadQuotation">MonadQuotation<span class="hover-container"><span class="hover-info"><code>Lean.MonadQuotation (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A monad that supports syntax quotations. Syntax quotations (in term
position) are monadic values that when executed retrieve the current "macro
scope" from the monad and apply it to every identifier they introduce
(independent of whether this identifier turns out to be a reference to an
existing declaration, or an actually fresh binding during further
elaboration). We also apply the position of the result of `getRef` to each
introduced symbol, which results in better error positions than not applying
any position. </code></span></span></span> <span class="var token" data-binding="var-_uniq.8919">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-Lean.MonadRef">MonadRef<span class="hover-container"><span class="hover-info"><code>Lean.MonadRef (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A `MonadRef` is a monad that has a `ref : Syntax` in the read-only state.
This is used to keep track of the location where we are working; if an exception
is thrown, the `ref` gives the location where the error will be reported,
assuming no more specific location is provided.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.8919">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span><span class="unknown token" data-binding="">]</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">¬</span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-quotedStx">quotedStx<span class="hover-container"><span class="hover-info"><code>quotedStx {m : Type → Type} [Monad m] [MonadQuotation m] [MonadRef m] (str : String) : m Syntax</code></span></span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">m</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.8919">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-2806">fun</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.8947">x<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-String">String<span class="hover-container"><span class="hover-info"><code>String : Type</code><span class="sep"></span><code class="docstring">`String` is the type of (UTF-8 encoded) strings.

The compiler overrides the data representation of this type to a byte sequence,
and both `String.utf8ByteSize` and `String.length` are cached and O(1).
</code></span></span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="const token" data-binding="const-Lean.Syntax.missing">.missing<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.missing : Syntax</code><span class="sep"></span><code class="docstring">A `missing` syntax corresponds to a portion of the syntax tree that is
missing because of a parse error. The indexing operator on Syntax also
returns `missing` for indexing out of bounds. </code></span></span></span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-17375526695887577702-2844-2846"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-2844">by<span class="hover-container"><span class="hover-info"><code class="docstring">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-17375526695887577702-2844-2846"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type</span> → <span class="sort token" data-binding="">Type</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9068">inst✝²<span class="hover-container"><span class="hover-info"><code>Monad m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Monad">Monad<span class="hover-container"><span class="hover-info"><code>Monad.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class="sep"></span><code class="docstring">A [monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)) is a
structure which abstracts the concept of sequential control flow.
It mainly consists of two operations:

* `pure : α → F α`
* `bind : F α → (α → F β) → F β` (written as `&gt;&gt;=`)

Like many functional programming languages, Lean makes extensive use of monads
for structuring programs. In particular, the `do` notation is a very powerful
syntax over monad operations, and it depends on a `Monad` instance.

See [the `do` notation](https://lean-lang.org/lean4/doc/do.html)
chapter of the manual for details.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9069">inst✝¹<span class="hover-container"><span class="hover-info"><code>MonadQuotation m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Lean.MonadQuotation">MonadQuotation<span class="hover-container"><span class="hover-info"><code>Lean.MonadQuotation (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A monad that supports syntax quotations. Syntax quotations (in term
position) are monadic values that when executed retrieve the current "macro
scope" from the monad and apply it to every identifier they introduce
(independent of whether this identifier turns out to be a reference to an
existing declaration, or an actually fresh binding during further
elaboration). We also apply the position of the result of `getRef` to each
introduced symbol, which results in better error positions than not applying
any position. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9070">inst✝<span class="hover-container"><span class="hover-info"><code>MonadRef m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Lean.MonadRef">MonadRef<span class="hover-container"><span class="hover-info"><code>Lean.MonadRef (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A `MonadRef` is a monad that has a `ref : Syntax` in the read-only state.
This is used to keep track of the location where we are working; if an exception
is thrown, the `ref` gives the location where the error will be reported,
assuming no more specific location is provided.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Not">¬<span class="hover-container"><span class="hover-info"><code>Not (a : Prop) : Prop</code><span class="sep"></span><code class="docstring">`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,
so if your goal is `¬p` you can use `intro h` to turn the goal into
`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`
and `(hn h).elim` will prove anything.
For more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)
</code></span></span></span>quotedStx<span class="const token" data-binding="const-Eq"> = <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.9658">x<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> =&gt; <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="const token" data-binding="const-Lean.Syntax.missing">Syntax.missing<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.missing : Syntax</code><span class="sep"></span><code class="docstring">A `missing` syntax corresponds to a portion of the syntax tree that is
missing because of a parse error. The indexing operator on Syntax also
returns `missing` for indexing out of bounds. </code></span></span></span></span></span></div></div></span>
  <span class="tactic"><label for="tactic-state-13007581078892601570-2849-2865"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.unfold-2849">unfold<span class="hover-container"><span class="hover-info"><code class="docstring">* `unfold id` unfolds definition `id`.
* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.

For non-recursive definitions, this tactic is identical to `delta`.
For definitions by pattern matching, it uses "equation lemmas" which are
autogenerated for each match arm.
</code></span></span></span> <span class="const token" data-binding="const-quotedStx">quotedStx<span class="hover-container"><span class="hover-info"><code>quotedStx {m : Type → Type} [Monad m] [MonadQuotation m] [MonadRef m] (str : String) : m Syntax</code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13007581078892601570-2849-2865"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type</span> → <span class="sort token" data-binding="">Type</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9068">inst✝²<span class="hover-container"><span class="hover-info"><code>Monad m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Monad">Monad<span class="hover-container"><span class="hover-info"><code>Monad.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class="sep"></span><code class="docstring">A [monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)) is a
structure which abstracts the concept of sequential control flow.
It mainly consists of two operations:

* `pure : α → F α`
* `bind : F α → (α → F β) → F β` (written as `&gt;&gt;=`)

Like many functional programming languages, Lean makes extensive use of monads
for structuring programs. In particular, the `do` notation is a very powerful
syntax over monad operations, and it depends on a `Monad` instance.

See [the `do` notation](https://lean-lang.org/lean4/doc/do.html)
chapter of the manual for details.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9069">inst✝¹<span class="hover-container"><span class="hover-info"><code>MonadQuotation m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Lean.MonadQuotation">MonadQuotation<span class="hover-container"><span class="hover-info"><code>Lean.MonadQuotation (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A monad that supports syntax quotations. Syntax quotations (in term
position) are monadic values that when executed retrieve the current "macro
scope" from the monad and apply it to every identifier they introduce
(independent of whether this identifier turns out to be a reference to an
existing declaration, or an actually fresh binding during further
elaboration). We also apply the position of the result of `getRef` to each
introduced symbol, which results in better error positions than not applying
any position. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9070">inst✝<span class="hover-container"><span class="hover-info"><code>MonadRef m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Lean.MonadRef">MonadRef<span class="hover-container"><span class="hover-info"><code>Lean.MonadRef (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A `MonadRef` is a monad that has a `ref : Syntax` in the read-only state.
This is used to keep track of the location where we are working; if an exception
is thrown, the `ref` gives the location where the error will be reported,
assuming no more specific location is provided.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Not">¬<span class="hover-container"><span class="hover-info"><code>Not (a : Prop) : Prop</code><span class="sep"></span><code class="docstring">`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,
so if your goal is `¬p` you can use `intro h` to turn the goal into
`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`
and `(hn h).elim` will prove anything.
For more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)
</code></span></span></span>(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> =&gt; <span class="keyword token" data-binding="">do</span>
      <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span> ←
        <span class="keyword token" data-binding="">do</span>
          <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> ← MonadRef.mkInfoFromRefPos
          <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span> ← getCurrMacroScope
          <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> ← getMainModule
          <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span>
              {
                <span class="const token" data-binding="const-Lean.TSyntax.raw">raw<span class="hover-container"><span class="hover-info"><code>Syntax</code><span class="sep"></span><code class="docstring">The underlying `Syntax` value. </code></span></span></span> :=
                  <span class="const token" data-binding="const-Lean.Syntax.node2">Syntax.node2<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node2 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 2 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `Lean.Parser.Term.app
                    (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"a"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"a"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `a <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                    (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"b"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"b"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `b <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                      (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"c"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"c"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `c <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                      (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `term#[_,] (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"#["<span class="hover-container"><span class="hover-info"><code><span class="literal string">"#["</span> : String</code></span></span></span>)
                        (<span class="const token" data-binding="const-Lean.Syntax.node5">Syntax.node5<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node5 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ a₄ a₅ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 5 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null
                          (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"x"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"x"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `x <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                          (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>) (<span class="const token" data-binding="const-Lean.Quote.quote">quote<span class="hover-container"><span class="hover-info"><code>Lean.Quote.quote {α : Type} {k : optParam SyntaxNodeKind `term} [self : Quote α k] : α → TSyntax k</code></span></span></span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span>).raw (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>)
                          (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"z"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"z"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `z <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) []))
                        (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"]"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"]"</span> : String</code></span></span></span>))) }
      <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span>.raw)<span class="const token" data-binding="const-Eq"> =
    <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.9784">x<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> =&gt; <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="const token" data-binding="const-Lean.Syntax.missing">Syntax.missing<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.missing : Syntax</code><span class="sep"></span><code class="docstring">A `missing` syntax corresponds to a portion of the syntax tree that is
missing because of a parse error. The indexing operator on Syntax also
returns `missing` for indexing out of bounds. </code></span></span></span></span></span></div></div></span>
  <span class="tactic"><label for="tactic-state-1879776070895254615-2868-2875"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.intro-2868">intro<span class="hover-container"><span class="hover-info"><code class="docstring">Introduces one or more hypotheses, optionally naming and/or pattern-matching them.
For each hypothesis to be introduced, the remaining main goal's target type must
be a `let` or function type.

* `intro` by itself introduces one anonymous hypothesis, which can be accessed
  by e.g. `assumption`.
* `intro x y` introduces two hypotheses and names them. Individual hypotheses
  can be anonymized via `_`, or matched against a pattern:
  ```lean
  -- ... ⊢ α × β → ...
  intro (a, b)
  -- ..., a : α, b : β ⊢ ...
  ```
* Alternatively, `intro` can be combined with pattern matching much like `fun`:
  ```lean
  intro
  | n + 1, 0 =&gt; tac
  | ...
  ```
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9080">h<span class="hover-container"><span class="hover-info"><code>(fun str =&gt; do
    let s ←
      do
        let info ← MonadRef.mkInfoFromRefPos
        let scp ← getCurrMacroScope
        let mainModule ← getMainModule
        pure
            {
              raw :=
                Syntax.node2 info `Lean.Parser.Term.app
                  (Syntax.ident info "a".toSubstring' (addMacroScope mainModule `a scp) [])
                  (Syntax.node3 info `null (Syntax.ident info "b".toSubstring' (addMacroScope mainModule `b scp) [])
                    (Syntax.ident info "c".toSubstring' (addMacroScope mainModule `c scp) [])
                    (Syntax.node3 info `term#[_,] (Syntax.atom info "#[")
                      (Syntax.node5 info `null (Syntax.ident info "x".toSubstring' (addMacroScope mainModule `x scp) [])
                        (Syntax.atom info ",") (quote str).raw (Syntax.atom info ",")
                        (Syntax.ident info "z".toSubstring' (addMacroScope mainModule `z scp) []))
                      (Syntax.atom info "]"))) }
    pure s.raw) =
  fun x =&gt; pure Syntax.missing</code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1879776070895254615-2868-2875"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type</span> → <span class="sort token" data-binding="">Type</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9068">inst✝²<span class="hover-container"><span class="hover-info"><code>Monad m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Monad">Monad<span class="hover-container"><span class="hover-info"><code>Monad.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class="sep"></span><code class="docstring">A [monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)) is a
structure which abstracts the concept of sequential control flow.
It mainly consists of two operations:

* `pure : α → F α`
* `bind : F α → (α → F β) → F β` (written as `&gt;&gt;=`)

Like many functional programming languages, Lean makes extensive use of monads
for structuring programs. In particular, the `do` notation is a very powerful
syntax over monad operations, and it depends on a `Monad` instance.

See [the `do` notation](https://lean-lang.org/lean4/doc/do.html)
chapter of the manual for details.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9069">inst✝¹<span class="hover-container"><span class="hover-info"><code>MonadQuotation m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Lean.MonadQuotation">MonadQuotation<span class="hover-container"><span class="hover-info"><code>Lean.MonadQuotation (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A monad that supports syntax quotations. Syntax quotations (in term
position) are monadic values that when executed retrieve the current "macro
scope" from the monad and apply it to every identifier they introduce
(independent of whether this identifier turns out to be a reference to an
existing declaration, or an actually fresh binding during further
elaboration). We also apply the position of the result of `getRef` to each
introduced symbol, which results in better error positions than not applying
any position. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9070">inst✝<span class="hover-container"><span class="hover-info"><code>MonadRef m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Lean.MonadRef">MonadRef<span class="hover-container"><span class="hover-info"><code>Lean.MonadRef (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A `MonadRef` is a monad that has a `ref : Syntax` in the read-only state.
This is used to keep track of the location where we are working; if an exception
is thrown, the `ref` gives the location where the error will be reported,
assuming no more specific location is provided.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9080">h<span class="hover-container"><span class="hover-info"><code>(fun str =&gt; do
    let s ←
      do
        let info ← MonadRef.mkInfoFromRefPos
        let scp ← getCurrMacroScope
        let mainModule ← getMainModule
        pure
            {
              raw :=
                Syntax.node2 info `Lean.Parser.Term.app
                  (Syntax.ident info "a".toSubstring' (addMacroScope mainModule `a scp) [])
                  (Syntax.node3 info `null (Syntax.ident info "b".toSubstring' (addMacroScope mainModule `b scp) [])
                    (Syntax.ident info "c".toSubstring' (addMacroScope mainModule `c scp) [])
                    (Syntax.node3 info `term#[_,] (Syntax.atom info "#[")
                      (Syntax.node5 info `null (Syntax.ident info "x".toSubstring' (addMacroScope mainModule `x scp) [])
                        (Syntax.atom info ",") (quote str).raw (Syntax.atom info ",")
                        (Syntax.ident info "z".toSubstring' (addMacroScope mainModule `z scp) []))
                      (Syntax.atom info "]"))) }
    pure s.raw) =
  fun x =&gt; pure Syntax.missing</code></span></span></span></td><td class="colon">:</td><td class="type">(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> =&gt; <span class="keyword token" data-binding="">do</span>
    <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span> ←
      <span class="keyword token" data-binding="">do</span>
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> ← MonadRef.mkInfoFromRefPos
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span> ← getCurrMacroScope
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> ← getMainModule
        <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span>
            {
              <span class="const token" data-binding="const-Lean.TSyntax.raw">raw<span class="hover-container"><span class="hover-info"><code>Syntax</code><span class="sep"></span><code class="docstring">The underlying `Syntax` value. </code></span></span></span> :=
                <span class="const token" data-binding="const-Lean.Syntax.node2">Syntax.node2<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node2 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 2 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `Lean.Parser.Term.app
                  (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"a"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"a"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `a <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                  (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"b"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"b"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `b <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                    (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"c"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"c"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `c <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                    (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `term#[_,] (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"#["<span class="hover-container"><span class="hover-info"><code><span class="literal string">"#["</span> : String</code></span></span></span>)
                      (<span class="const token" data-binding="const-Lean.Syntax.node5">Syntax.node5<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node5 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ a₄ a₅ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 5 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"x"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"x"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `x <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                        (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>) (<span class="const token" data-binding="const-Lean.Quote.quote">quote<span class="hover-container"><span class="hover-info"><code>Lean.Quote.quote {α : Type} {k : optParam SyntaxNodeKind `term} [self : Quote α k] : α → TSyntax k</code></span></span></span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span>).raw (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>)
                        (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"z"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"z"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `z <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) []))
                      (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"]"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"]"</span> : String</code></span></span></span>))) }
    <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span>.raw)<span class="const token" data-binding="const-Eq"> =
  <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.9784">x<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> =&gt; <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="const token" data-binding="const-Lean.Syntax.missing">Syntax.missing<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.missing : Syntax</code><span class="sep"></span><code class="docstring">A `missing` syntax corresponds to a portion of the syntax tree that is
missing because of a parse error. The indexing operator on Syntax also
returns `missing` for indexing out of bounds. </code></span></span></span></td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-False">False<span class="hover-container"><span class="hover-info"><code>False : Prop</code><span class="sep"></span><code class="docstring">`False` is the empty proposition. Thus, it has no introduction rules.
It represents a contradiction. `False` elimination rule, `False.rec`,
expresses the fact that anything follows from a contradiction.
This rule is sometimes called ex falso (short for ex falso sequitur quodlibet),
or the principle of explosion.
For more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)
</code></span></span></span></span></span></div></div></span>
  <span class="tactic"><label for="tactic-state-14605732929691846506-2878-2978"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticLet_-2878">let<span class="hover-container"><span class="hover-info"><code class="docstring">The `let` tactic is for adding definitions to the local context of the main goal.
* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.
* `let x := e` uses the type of `e` for `t`.
* `let : t := e` and `let := e` use `this` for the name of the hypothesis.
* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that let only one applicable constructor.
  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the
  local variables `x : α`, `y : β`, and `z : γ`.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9616">g<span class="hover-container"><span class="hover-info"><code>String → m Syntax</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-String">String<span class="hover-container"><span class="hover-info"><code>String : Type</code><span class="sep"></span><code class="docstring">`String` is the type of (UTF-8 encoded) strings.

The compiler overrides the data representation of this type to a byte sequence,
and both `String.utf8ByteSize` and `String.length` are cached and O(1).
</code></span></span></span> <span class="unknown token" data-binding="">→</span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span> <span class="const token" data-binding="const-Lean.Syntax">Syntax<span class="hover-container"><span class="hover-info"><code>Lean.Syntax : Type</code><span class="sep"></span><code class="docstring">Syntax objects used by the parser, macro expander, delaborator, etc.
</code></span></span></span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-2909">fun</span> <span class="var token" data-binding="var-_uniq.9088">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-2920">do</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-2927">let</span> <span class="var token" data-binding="var-_uniq.9503">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span> <span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">`(</span><span class="unknown token" data-binding="">a</span> <span class="unknown token" data-binding="">b</span> <span class="unknown token" data-binding="">c</span> <span class="unknown token" data-binding="">#[</span><span class="unknown token" data-binding="">x</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">$</span><span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Quote.quote">quote<span class="hover-container"><span class="hover-info"><code>Lean.Quote.quote {α : Type} {k : optParam SyntaxNodeKind `term} [self : Quote α k] : α → TSyntax k</code></span></span></span> <span class="var token" data-binding="var-_uniq.9088">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">z</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span>
    <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9503">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14605732929691846506-2878-2978"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type</span> → <span class="sort token" data-binding="">Type</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9068">inst✝²<span class="hover-container"><span class="hover-info"><code>Monad m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Monad">Monad<span class="hover-container"><span class="hover-info"><code>Monad.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class="sep"></span><code class="docstring">A [monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)) is a
structure which abstracts the concept of sequential control flow.
It mainly consists of two operations:

* `pure : α → F α`
* `bind : F α → (α → F β) → F β` (written as `&gt;&gt;=`)

Like many functional programming languages, Lean makes extensive use of monads
for structuring programs. In particular, the `do` notation is a very powerful
syntax over monad operations, and it depends on a `Monad` instance.

See [the `do` notation](https://lean-lang.org/lean4/doc/do.html)
chapter of the manual for details.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9069">inst✝¹<span class="hover-container"><span class="hover-info"><code>MonadQuotation m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Lean.MonadQuotation">MonadQuotation<span class="hover-container"><span class="hover-info"><code>Lean.MonadQuotation (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A monad that supports syntax quotations. Syntax quotations (in term
position) are monadic values that when executed retrieve the current "macro
scope" from the monad and apply it to every identifier they introduce
(independent of whether this identifier turns out to be a reference to an
existing declaration, or an actually fresh binding during further
elaboration). We also apply the position of the result of `getRef` to each
introduced symbol, which results in better error positions than not applying
any position. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9070">inst✝<span class="hover-container"><span class="hover-info"><code>MonadRef m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Lean.MonadRef">MonadRef<span class="hover-container"><span class="hover-info"><code>Lean.MonadRef (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A `MonadRef` is a monad that has a `ref : Syntax` in the read-only state.
This is used to keep track of the location where we are working; if an exception
is thrown, the `ref` gives the location where the error will be reported,
assuming no more specific location is provided.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9080">h<span class="hover-container"><span class="hover-info"><code>(fun str =&gt; do
    let s ←
      do
        let info ← MonadRef.mkInfoFromRefPos
        let scp ← getCurrMacroScope
        let mainModule ← getMainModule
        pure
            {
              raw :=
                Syntax.node2 info `Lean.Parser.Term.app
                  (Syntax.ident info "a".toSubstring' (addMacroScope mainModule `a scp) [])
                  (Syntax.node3 info `null (Syntax.ident info "b".toSubstring' (addMacroScope mainModule `b scp) [])
                    (Syntax.ident info "c".toSubstring' (addMacroScope mainModule `c scp) [])
                    (Syntax.node3 info `term#[_,] (Syntax.atom info "#[")
                      (Syntax.node5 info `null (Syntax.ident info "x".toSubstring' (addMacroScope mainModule `x scp) [])
                        (Syntax.atom info ",") (quote str).raw (Syntax.atom info ",")
                        (Syntax.ident info "z".toSubstring' (addMacroScope mainModule `z scp) []))
                      (Syntax.atom info "]"))) }
    pure s.raw) =
  fun x =&gt; pure Syntax.missing</code></span></span></span></td><td class="colon">:</td><td class="type">(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> =&gt; <span class="keyword token" data-binding="">do</span>
    <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span> ←
      <span class="keyword token" data-binding="">do</span>
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> ← MonadRef.mkInfoFromRefPos
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span> ← getCurrMacroScope
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> ← getMainModule
        <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span>
            {
              <span class="const token" data-binding="const-Lean.TSyntax.raw">raw<span class="hover-container"><span class="hover-info"><code>Syntax</code><span class="sep"></span><code class="docstring">The underlying `Syntax` value. </code></span></span></span> :=
                <span class="const token" data-binding="const-Lean.Syntax.node2">Syntax.node2<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node2 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 2 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `Lean.Parser.Term.app
                  (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"a"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"a"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `a <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                  (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"b"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"b"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `b <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                    (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"c"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"c"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `c <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                    (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `term#[_,] (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"#["<span class="hover-container"><span class="hover-info"><code><span class="literal string">"#["</span> : String</code></span></span></span>)
                      (<span class="const token" data-binding="const-Lean.Syntax.node5">Syntax.node5<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node5 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ a₄ a₅ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 5 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"x"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"x"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `x <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                        (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>) (<span class="const token" data-binding="const-Lean.Quote.quote">quote<span class="hover-container"><span class="hover-info"><code>Lean.Quote.quote {α : Type} {k : optParam SyntaxNodeKind `term} [self : Quote α k] : α → TSyntax k</code></span></span></span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span>).raw (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>)
                        (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"z"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"z"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `z <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) []))
                      (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"]"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"]"</span> : String</code></span></span></span>))) }
    <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span>.raw)<span class="const token" data-binding="const-Eq"> =
  <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.9784">x<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> =&gt; <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="const token" data-binding="const-Lean.Syntax.missing">Syntax.missing<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.missing : Syntax</code><span class="sep"></span><code class="docstring">A `missing` syntax corresponds to a portion of the syntax tree that is
missing because of a parse error. The indexing operator on Syntax also
returns `missing` for indexing out of bounds. </code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9616">g<span class="hover-container"><span class="hover-info"><code>String → m Syntax</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-String">String<span class="hover-container"><span class="hover-info"><code>String : Type</code><span class="sep"></span><code class="docstring">`String` is the type of (UTF-8 encoded) strings.

The compiler overrides the data representation of this type to a byte sequence,
and both `String.utf8ByteSize` and `String.length` are cached and O(1).
</code></span></span></span> → <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span> <span class="const token" data-binding="const-Lean.Syntax">Syntax<span class="hover-container"><span class="hover-info"><code>Lean.Syntax : Type</code><span class="sep"></span><code class="docstring">Syntax objects used by the parser, macro expander, delaborator, etc.
</code></span></span></span> := 
  <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> =&gt; <span class="keyword token" data-binding="">do</span>
    <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span> ←
      <span class="keyword token" data-binding="">do</span>
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> ← MonadRef.mkInfoFromRefPos
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span> ← getCurrMacroScope
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> ← getMainModule
        <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span>
            {
              <span class="const token" data-binding="const-Lean.TSyntax.raw">raw<span class="hover-container"><span class="hover-info"><code>Syntax</code><span class="sep"></span><code class="docstring">The underlying `Syntax` value. </code></span></span></span> :=
                <span class="const token" data-binding="const-Lean.Syntax.node2">Syntax.node2<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node2 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 2 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `Lean.Parser.Term.app
                  (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"a"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"a"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `a <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                  (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"b"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"b"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `b <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                    (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"c"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"c"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `c <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                    (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `term#[_,] (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"#["<span class="hover-container"><span class="hover-info"><code><span class="literal string">"#["</span> : String</code></span></span></span>)
                      (<span class="const token" data-binding="const-Lean.Syntax.node5">Syntax.node5<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node5 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ a₄ a₅ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 5 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"x"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"x"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `x <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                        (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>) (<span class="const token" data-binding="const-Lean.Quote.quote">quote<span class="hover-container"><span class="hover-info"><code>Lean.Quote.quote {α : Type} {k : optParam SyntaxNodeKind `term} [self : Quote α k] : α → TSyntax k</code></span></span></span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span>).raw (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>)
                        (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"z"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"z"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `z <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) []))
                      (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"]"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"]"</span> : String</code></span></span></span>))) }
    <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span>.raw</td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type">False</span></span></div></div></span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticHave_-2981">have<span class="hover-container"><span class="hover-info"><code class="docstring">The `have` tactic is for adding hypotheses to the local context of the main goal.
* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.
* `have h := e` uses the type of `e` for `t`.
* `have : t := e` and `have := e` use `this` for the name of the hypothesis.
* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,
  where `_` stands for the tactics that follow this one.
  It is convenient for types that have only one applicable constructor.
  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the
  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.
</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.9616">g<span class="hover-container"><span class="hover-info"><code>String → m Syntax</code></span></span></span> <span class="literal string token" data-binding="">"hello"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"hello"</span> : String</code></span></span></span> <span class="unknown token" data-binding="">≠</span> <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="const token" data-binding="const-Lean.Syntax.missing">.missing<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.missing : Syntax</code><span class="sep"></span><code class="docstring">A `missing` syntax corresponds to a portion of the syntax tree that is
missing because of a parse error. The indexing operator on Syntax also
returns `missing` for indexing out of bounds. </code></span></span></span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-4599275542244626340-3019-3021"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-3019">by<span class="hover-container"><span class="hover-info"><code class="docstring">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4599275542244626340-3019-3021"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type</span> → <span class="sort token" data-binding="">Type</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9068">inst✝²<span class="hover-container"><span class="hover-info"><code>Monad m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Monad">Monad<span class="hover-container"><span class="hover-info"><code>Monad.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class="sep"></span><code class="docstring">A [monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)) is a
structure which abstracts the concept of sequential control flow.
It mainly consists of two operations:

* `pure : α → F α`
* `bind : F α → (α → F β) → F β` (written as `&gt;&gt;=`)

Like many functional programming languages, Lean makes extensive use of monads
for structuring programs. In particular, the `do` notation is a very powerful
syntax over monad operations, and it depends on a `Monad` instance.

See [the `do` notation](https://lean-lang.org/lean4/doc/do.html)
chapter of the manual for details.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9069">inst✝¹<span class="hover-container"><span class="hover-info"><code>MonadQuotation m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Lean.MonadQuotation">MonadQuotation<span class="hover-container"><span class="hover-info"><code>Lean.MonadQuotation (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A monad that supports syntax quotations. Syntax quotations (in term
position) are monadic values that when executed retrieve the current "macro
scope" from the monad and apply it to every identifier they introduce
(independent of whether this identifier turns out to be a reference to an
existing declaration, or an actually fresh binding during further
elaboration). We also apply the position of the result of `getRef` to each
introduced symbol, which results in better error positions than not applying
any position. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9070">inst✝<span class="hover-container"><span class="hover-info"><code>MonadRef m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Lean.MonadRef">MonadRef<span class="hover-container"><span class="hover-info"><code>Lean.MonadRef (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A `MonadRef` is a monad that has a `ref : Syntax` in the read-only state.
This is used to keep track of the location where we are working; if an exception
is thrown, the `ref` gives the location where the error will be reported,
assuming no more specific location is provided.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9080">h<span class="hover-container"><span class="hover-info"><code>(fun str =&gt; do
    let s ←
      do
        let info ← MonadRef.mkInfoFromRefPos
        let scp ← getCurrMacroScope
        let mainModule ← getMainModule
        pure
            {
              raw :=
                Syntax.node2 info `Lean.Parser.Term.app
                  (Syntax.ident info "a".toSubstring' (addMacroScope mainModule `a scp) [])
                  (Syntax.node3 info `null (Syntax.ident info "b".toSubstring' (addMacroScope mainModule `b scp) [])
                    (Syntax.ident info "c".toSubstring' (addMacroScope mainModule `c scp) [])
                    (Syntax.node3 info `term#[_,] (Syntax.atom info "#[")
                      (Syntax.node5 info `null (Syntax.ident info "x".toSubstring' (addMacroScope mainModule `x scp) [])
                        (Syntax.atom info ",") (quote str).raw (Syntax.atom info ",")
                        (Syntax.ident info "z".toSubstring' (addMacroScope mainModule `z scp) []))
                      (Syntax.atom info "]"))) }
    pure s.raw) =
  fun x =&gt; pure Syntax.missing</code></span></span></span></td><td class="colon">:</td><td class="type">(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> =&gt; <span class="keyword token" data-binding="">do</span>
    <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span> ←
      <span class="keyword token" data-binding="">do</span>
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> ← MonadRef.mkInfoFromRefPos
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span> ← getCurrMacroScope
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> ← getMainModule
        <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span>
            {
              <span class="const token" data-binding="const-Lean.TSyntax.raw">raw<span class="hover-container"><span class="hover-info"><code>Syntax</code><span class="sep"></span><code class="docstring">The underlying `Syntax` value. </code></span></span></span> :=
                <span class="const token" data-binding="const-Lean.Syntax.node2">Syntax.node2<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node2 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 2 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `Lean.Parser.Term.app
                  (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"a"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"a"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `a <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                  (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"b"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"b"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `b <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                    (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"c"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"c"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `c <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                    (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `term#[_,] (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"#["<span class="hover-container"><span class="hover-info"><code><span class="literal string">"#["</span> : String</code></span></span></span>)
                      (<span class="const token" data-binding="const-Lean.Syntax.node5">Syntax.node5<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node5 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ a₄ a₅ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 5 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"x"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"x"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `x <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                        (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>) (<span class="const token" data-binding="const-Lean.Quote.quote">quote<span class="hover-container"><span class="hover-info"><code>Lean.Quote.quote {α : Type} {k : optParam SyntaxNodeKind `term} [self : Quote α k] : α → TSyntax k</code></span></span></span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span>).raw (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>)
                        (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"z"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"z"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `z <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) []))
                      (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"]"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"]"</span> : String</code></span></span></span>))) }
    <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span>.raw)<span class="const token" data-binding="const-Eq"> =
  <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.9784">x<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> =&gt; <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="const token" data-binding="const-Lean.Syntax.missing">Syntax.missing<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.missing : Syntax</code><span class="sep"></span><code class="docstring">A `missing` syntax corresponds to a portion of the syntax tree that is
missing because of a parse error. The indexing operator on Syntax also
returns `missing` for indexing out of bounds. </code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9616">g<span class="hover-container"><span class="hover-info"><code>String → m Syntax</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-String">String<span class="hover-container"><span class="hover-info"><code>String : Type</code><span class="sep"></span><code class="docstring">`String` is the type of (UTF-8 encoded) strings.

The compiler overrides the data representation of this type to a byte sequence,
and both `String.utf8ByteSize` and `String.length` are cached and O(1).
</code></span></span></span> → <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span> <span class="const token" data-binding="const-Lean.Syntax">Syntax<span class="hover-container"><span class="hover-info"><code>Lean.Syntax : Type</code><span class="sep"></span><code class="docstring">Syntax objects used by the parser, macro expander, delaborator, etc.
</code></span></span></span> := 
  <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> =&gt; <span class="keyword token" data-binding="">do</span>
    <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span> ←
      <span class="keyword token" data-binding="">do</span>
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> ← MonadRef.mkInfoFromRefPos
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span> ← getCurrMacroScope
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> ← getMainModule
        <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span>
            {
              <span class="const token" data-binding="const-Lean.TSyntax.raw">raw<span class="hover-container"><span class="hover-info"><code>Syntax</code><span class="sep"></span><code class="docstring">The underlying `Syntax` value. </code></span></span></span> :=
                <span class="const token" data-binding="const-Lean.Syntax.node2">Syntax.node2<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node2 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 2 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `Lean.Parser.Term.app
                  (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"a"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"a"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `a <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                  (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"b"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"b"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `b <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                    (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"c"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"c"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `c <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                    (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `term#[_,] (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"#["<span class="hover-container"><span class="hover-info"><code><span class="literal string">"#["</span> : String</code></span></span></span>)
                      (<span class="const token" data-binding="const-Lean.Syntax.node5">Syntax.node5<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node5 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ a₄ a₅ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 5 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"x"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"x"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `x <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                        (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>) (<span class="const token" data-binding="const-Lean.Quote.quote">quote<span class="hover-container"><span class="hover-info"><code>Lean.Quote.quote {α : Type} {k : optParam SyntaxNodeKind `term} [self : Quote α k] : α → TSyntax k</code></span></span></span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span>).raw (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>)
                        (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"z"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"z"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `z <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) []))
                      (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"]"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"]"</span> : String</code></span></span></span>))) }
    <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span>.raw</td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.9616">g<span class="hover-container"><span class="hover-info"><code>String → m Syntax</code></span></span></span> <span class="literal string token" data-binding="">"hello"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"hello"</span> : String</code></span></span></span><span class="const token" data-binding="const-Ne"> ≠ <span class="hover-container"><span class="hover-info"><code>Ne.{u} {α : Sort u} (a b : α) : Prop</code><span class="sep"></span><code class="docstring">`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,
and asserts that `a` and `b` are not equal.
</code></span></span></span><span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="const token" data-binding="const-Lean.Syntax.missing">Syntax.missing<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.missing : Syntax</code><span class="sep"></span><code class="docstring">A `missing` syntax corresponds to a portion of the syntax tree that is
missing because of a parse error. The indexing operator on Syntax also
returns `missing` for indexing out of bounds. </code></span></span></span></span></span></div></div></span> <span class="tactic"><label for="tactic-state-4599275542244626340-3022-3026"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.skip-3022">skip<span class="hover-container"><span class="hover-info"><code class="docstring">`skip` does nothing. </code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-4599275542244626340-3022-3026"><div class="tactic-state"><div class="goal"><table class="hypotheses"><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="sort token" data-binding="">Type</span> → <span class="sort token" data-binding="">Type</span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9068">inst✝²<span class="hover-container"><span class="hover-info"><code>Monad m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Monad">Monad<span class="hover-container"><span class="hover-info"><code>Monad.{u, v} (m : Type u → Type v) : Type (max (u + 1) v)</code><span class="sep"></span><code class="docstring">A [monad](https://en.wikipedia.org/wiki/Monad_(functional_programming)) is a
structure which abstracts the concept of sequential control flow.
It mainly consists of two operations:

* `pure : α → F α`
* `bind : F α → (α → F β) → F β` (written as `&gt;&gt;=`)

Like many functional programming languages, Lean makes extensive use of monads
for structuring programs. In particular, the `do` notation is a very powerful
syntax over monad operations, and it depends on a `Monad` instance.

See [the `do` notation](https://lean-lang.org/lean4/doc/do.html)
chapter of the manual for details.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9069">inst✝¹<span class="hover-container"><span class="hover-info"><code>MonadQuotation m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Lean.MonadQuotation">MonadQuotation<span class="hover-container"><span class="hover-info"><code>Lean.MonadQuotation (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A monad that supports syntax quotations. Syntax quotations (in term
position) are monadic values that when executed retrieve the current "macro
scope" from the monad and apply it to every identifier they introduce
(independent of whether this identifier turns out to be a reference to an
existing declaration, or an actually fresh binding during further
elaboration). We also apply the position of the result of `getRef` to each
introduced symbol, which results in better error positions than not applying
any position. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9070">inst✝<span class="hover-container"><span class="hover-info"><code>MonadRef m</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-Lean.MonadRef">MonadRef<span class="hover-container"><span class="hover-info"><code>Lean.MonadRef (m : Type → Type) : Type 1</code><span class="sep"></span><code class="docstring">A `MonadRef` is a monad that has a `ref : Syntax` in the read-only state.
This is used to keep track of the location where we are working; if an exception
is thrown, the `ref` gives the location where the error will be reported,
assuming no more specific location is provided.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9080">h<span class="hover-container"><span class="hover-info"><code>(fun str =&gt; do
    let s ←
      do
        let info ← MonadRef.mkInfoFromRefPos
        let scp ← getCurrMacroScope
        let mainModule ← getMainModule
        pure
            {
              raw :=
                Syntax.node2 info `Lean.Parser.Term.app
                  (Syntax.ident info "a".toSubstring' (addMacroScope mainModule `a scp) [])
                  (Syntax.node3 info `null (Syntax.ident info "b".toSubstring' (addMacroScope mainModule `b scp) [])
                    (Syntax.ident info "c".toSubstring' (addMacroScope mainModule `c scp) [])
                    (Syntax.node3 info `term#[_,] (Syntax.atom info "#[")
                      (Syntax.node5 info `null (Syntax.ident info "x".toSubstring' (addMacroScope mainModule `x scp) [])
                        (Syntax.atom info ",") (quote str).raw (Syntax.atom info ",")
                        (Syntax.ident info "z".toSubstring' (addMacroScope mainModule `z scp) []))
                      (Syntax.atom info "]"))) }
    pure s.raw) =
  fun x =&gt; pure Syntax.missing</code></span></span></span></td><td class="colon">:</td><td class="type">(<span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> =&gt; <span class="keyword token" data-binding="">do</span>
    <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span> ←
      <span class="keyword token" data-binding="">do</span>
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> ← MonadRef.mkInfoFromRefPos
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span> ← getCurrMacroScope
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> ← getMainModule
        <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span>
            {
              <span class="const token" data-binding="const-Lean.TSyntax.raw">raw<span class="hover-container"><span class="hover-info"><code>Syntax</code><span class="sep"></span><code class="docstring">The underlying `Syntax` value. </code></span></span></span> :=
                <span class="const token" data-binding="const-Lean.Syntax.node2">Syntax.node2<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node2 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 2 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `Lean.Parser.Term.app
                  (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"a"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"a"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `a <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                  (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"b"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"b"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `b <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                    (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"c"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"c"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `c <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                    (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `term#[_,] (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"#["<span class="hover-container"><span class="hover-info"><code><span class="literal string">"#["</span> : String</code></span></span></span>)
                      (<span class="const token" data-binding="const-Lean.Syntax.node5">Syntax.node5<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node5 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ a₄ a₅ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 5 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"x"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"x"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `x <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                        (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>) (<span class="const token" data-binding="const-Lean.Quote.quote">quote<span class="hover-container"><span class="hover-info"><code>Lean.Quote.quote {α : Type} {k : optParam SyntaxNodeKind `term} [self : Quote α k] : α → TSyntax k</code></span></span></span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span>).raw (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>)
                        (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"z"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"z"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `z <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) []))
                      (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"]"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"]"</span> : String</code></span></span></span>))) }
    <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span>.raw)<span class="const token" data-binding="const-Eq"> =
  <span class="hover-container"><span class="hover-info"><code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class="sep"></span><code class="docstring">The equality relation. It has one introduction rule, `Eq.refl`.
We use `a = b` as notation for `Eq a b`.
A fundamental property of equality is that it is an equivalence relation.
```
variable (α : Type) (a b c d : α)
variable (hab : a = b) (hcb : c = b) (hcd : c = d)

example : a = d :=
  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd
```
Equality is much more than an equivalence relation, however. It has the important property that every assertion
respects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.
That is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.
Example:
```
example (α : Type) (a b : α) (p : α → Prop)
        (h1 : a = b) (h2 : p a) : p b :=
  Eq.subst h1 h2

example (α : Type) (a b : α) (p : α → Prop)
    (h1 : a = b) (h2 : p a) : p b :=
  h1 ▸ h2
```
The triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\t`.
For more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)
</code></span></span></span><span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.9784">x<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> =&gt; <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="const token" data-binding="const-Lean.Syntax.missing">Syntax.missing<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.missing : Syntax</code><span class="sep"></span><code class="docstring">A `missing` syntax corresponds to a portion of the syntax tree that is
missing because of a parse error. The indexing operator on Syntax also
returns `missing` for indexing out of bounds. </code></span></span></span></td></tr><tr class="hypothesis"><td class="name"><span class="var token" data-binding="var-_uniq.9616">g<span class="hover-container"><span class="hover-info"><code>String → m Syntax</code></span></span></span></td><td class="colon">:</td><td class="type"><span class="const token" data-binding="const-String">String<span class="hover-container"><span class="hover-info"><code>String : Type</code><span class="sep"></span><code class="docstring">`String` is the type of (UTF-8 encoded) strings.

The compiler overrides the data representation of this type to a byte sequence,
and both `String.utf8ByteSize` and `String.length` are cached and O(1).
</code></span></span></span> → <span class="var token" data-binding="var-_uniq.9067">m<span class="hover-container"><span class="hover-info"><code>Type → Type</code></span></span></span> <span class="const token" data-binding="const-Lean.Syntax">Syntax<span class="hover-container"><span class="hover-info"><code>Lean.Syntax : Type</code><span class="sep"></span><code class="docstring">Syntax objects used by the parser, macro expander, delaborator, etc.
</code></span></span></span> := 
  <span class="keyword token" data-binding="">fun</span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span> =&gt; <span class="keyword token" data-binding="">do</span>
    <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span> ←
      <span class="keyword token" data-binding="">do</span>
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> ← MonadRef.mkInfoFromRefPos
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span> ← getCurrMacroScope
        <span class="keyword token" data-binding="">let</span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> ← getMainModule
        <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span>
            {
              <span class="const token" data-binding="const-Lean.TSyntax.raw">raw<span class="hover-container"><span class="hover-info"><code>Syntax</code><span class="sep"></span><code class="docstring">The underlying `Syntax` value. </code></span></span></span> :=
                <span class="const token" data-binding="const-Lean.Syntax.node2">Syntax.node2<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node2 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 2 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `Lean.Parser.Term.app
                  (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"a"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"a"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `a <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                  (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"b"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"b"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `b <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                    (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"c"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"c"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `c <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                    (<span class="const token" data-binding="const-Lean.Syntax.node3">Syntax.node3<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node3 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 3 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `term#[_,] (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"#["<span class="hover-container"><span class="hover-info"><code><span class="literal string">"#["</span> : String</code></span></span></span>)
                      (<span class="const token" data-binding="const-Lean.Syntax.node5">Syntax.node5<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.node5 (info : SourceInfo) (kind : SyntaxNodeKind) (a₁ a₂ a₃ a₄ a₅ : Syntax) : Syntax</code><span class="sep"></span><code class="docstring">Create syntax node with 5 children </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> `null (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"x"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"x"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `x <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) [])
                        (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>) (<span class="const token" data-binding="const-Lean.Quote.quote">quote<span class="hover-container"><span class="hover-info"><code>Lean.Quote.quote {α : Type} {k : optParam SyntaxNodeKind `term} [self : Quote α k] : α → TSyntax k</code></span></span></span> <span class="var token" data-binding="var-_uniq.9657">str<span class="hover-container"><span class="hover-info"><code>String</code></span></span></span>).raw (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">","<span class="hover-container"><span class="hover-info"><code><span class="literal string">","</span> : String</code></span></span></span>)
                        (<span class="const token" data-binding="const-Lean.Syntax.ident">Syntax.ident<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.ident (info : SourceInfo) (rawVal : Substring) (val : Name) (preresolved : List Syntax.Preresolved) : Syntax</code><span class="sep"></span><code class="docstring">An `ident` corresponds to an identifier as parsed by the `ident` or
`rawIdent` parsers.
* `rawVal` is the literal substring from the input file
* `val` is the parsed identifier (with hygiene)
* `preresolved` is the list of possible declarations this could refer to
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"z"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"z"</span> : String</code></span></span></span>.toSubstring' (<span class="const token" data-binding="const-Lean.addMacroScope">addMacroScope<span class="hover-container"><span class="hover-info"><code>Lean.addMacroScope (mainModule n : Name) (scp : MacroScope) : Name</code><span class="sep"></span><code class="docstring">Add a new macro scope onto the name `n`, in the given `mainModule`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9676">mainModule<span class="hover-container"><span class="hover-info"><code>Name</code></span></span></span> `z <span class="var token" data-binding="var-_uniq.9671">scp<span class="hover-container"><span class="hover-info"><code>MacroScope</code></span></span></span>) []))
                      (<span class="const token" data-binding="const-Lean.Syntax.atom">Syntax.atom<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.atom (info : SourceInfo) (val : String) : Syntax</code><span class="sep"></span><code class="docstring">An `atom` corresponds to a keyword or piece of literal unquoted syntax.
These correspond to quoted strings inside `syntax` declarations.
For example, in `(x + y)`, `"("`, `"+"` and `")"` are `atom`
and `x` and `y` are `ident`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9665">info<span class="hover-container"><span class="hover-info"><code>SourceInfo</code></span></span></span> <span class="literal string token" data-binding="">"]"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"]"</span> : String</code></span></span></span>))) }
    <span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9778">s<span class="hover-container"><span class="hover-info"><code>TSyntax `term</code></span></span></span>.raw</td></tr></table><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.9616">g<span class="hover-container"><span class="hover-info"><code>String → m Syntax</code></span></span></span> <span class="literal string token" data-binding="">"hello"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"hello"</span> : String</code></span></span></span><span class="const token" data-binding="const-Ne"> ≠ <span class="hover-container"><span class="hover-info"><code>Ne.{u} {α : Sort u} (a b : α) : Prop</code><span class="sep"></span><code class="docstring">`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,
and asserts that `a` and `b` are not equal.
</code></span></span></span><span class="const token" data-binding="const-Pure.pure">pure<span class="hover-container"><span class="hover-info"><code>Pure.pure.{u, v} {f : Type u → Type v} [self : Pure f] {α : Type u} : α → f α</code><span class="sep"></span><code class="docstring">If `a : α`, then `pure a : f α` represents a monadic action that does
nothing and returns `a`. </code></span></span></span> <span class="const token" data-binding="const-Lean.Syntax.missing">Syntax.missing<span class="hover-container"><span class="hover-info"><code>Lean.Syntax.missing : Syntax</code><span class="sep"></span><code class="docstring">A `missing` syntax corresponds to a portion of the syntax tree that is
missing because of a parse error. The indexing operator on Syntax also
returns `missing` for indexing out of bounds. </code></span></span></span></span></span></div></div></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-3028-3033"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-3028">sorry<span class="hover-container"><span class="hover-info"><code class="docstring">The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete
parts of a proof while still having a syntactically correct proof skeleton. Lean will give
a warning whenever a proof uses `sorry`, so you aren't likely to miss it, but
you can double check if a theorem depends on `sorry` by using
`#print axioms my_thm` and looking for `sorryAx` in the axiom list.
</code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-3028-3033"><div class="tactic-state">All goals completed! 🐙</div></span>
  <span class="tactic"><label for="tactic-state-7-3036-3041"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-3036">sorry<span class="hover-container"><span class="hover-info"><code class="docstring">The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete
parts of a proof while still having a syntactically correct proof skeleton. Lean will give
a warning whenever a proof uses `sorry`, so you aren't likely to miss it, but
you can double check if a theorem depends on `sorry` by using
`#print axioms my_thm` and looking for `sorryAx` in the axiom list.
</code></span></span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-3036-3041"><div class="tactic-state">All goals completed! 🐙</div></span>
<span class="unknown token" data-binding=""></span></code><p>
          It's possible to render a lot of info on one example:</p>
        <code class="hl lean block" data-lean-context="demo"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-3114">elab</span> <span class="literal string token" data-binding="">"%much_info("<span class="hover-container"><span class="hover-info"><code><span class="literal string">"%much_info("</span> : String</code></span></span></span> <span class="var token" data-binding="var-_uniq.9729">t<span class="hover-container"><span class="hover-info"><code>Lean.TSyntax `term</code></span></span></span><span class="unknown token" data-binding="">:</span><span class="const token" data-binding="const-Lean.Parser.Category.term">term<span class="hover-container"><span class="hover-info"><code>Lean.Parser.Category.term : Lean.Parser.Category</code><span class="sep"></span><code class="docstring">`term` is the builtin syntax category for terms. A term denotes an expression
in lean's type theory, for example `2 + 2` is a term. The difference between
`Term` and `Expr` is that the former is a kind of syntax, while the latter is
the result of elaboration. For example `by simp` is also a `Term`, but it elaborates
to different `Expr`s depending on the context. </code></span></span></span> <span class="literal string token" data-binding="">")"<span class="hover-container"><span class="hover-info"><code><span class="literal string">")"</span> : String</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.term">term<span class="hover-container"><span class="hover-info"><code>Lean.Parser.Category.term : Lean.Parser.Category</code><span class="sep"></span><code class="docstring">`term` is the builtin syntax category for terms. A term denotes an expression
in lean's type theory, for example `2 + 2` is a term. The difference between
`Term` and `Expr` is that the former is a kind of syntax, while the latter is
the result of elaboration. For example `by simp` is also a `Term`, but it elaborates
to different `Expr`s depending on the context. </code></span></span></span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.open-3154">open<span class="hover-container"><span class="hover-info"><code class="docstring">`open Foo in e` is like `open Foo` but scoped to a single term.
It makes the given namespaces available in the term `e`.
</code></span></span></span> <span class="unknown token" data-binding="">Lean</span> <span class="unknown token" data-binding="">Elab</span> <span class="unknown token" data-binding="">Term</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.open-3154">in<span class="hover-container"><span class="hover-info"><code class="docstring">`open Foo in e` is like `open Foo` but scoped to a single term.
It makes the given namespaces available in the term `e`.
</code></span></span></span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-3177">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-3182">for<span class="hover-container"><span class="hover-info"><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9864">i<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-3186">in</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">:</span><span class="unknown token" data-binding="">20</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-3182">do<span class="hover-container"><span class="hover-info"><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></span></span></span>
    <span class="const token" data-binding="const-Lean.logInfoAt">logInfoAt<span class="hover-container"><span class="hover-info"><code>Lean.logInfoAt {m : Type → Type} [Monad m] [Lean.MonadLog m] [Lean.AddMessageContext m] [Lean.MonadOptions m]
  (ref : Lean.Syntax) (msgData : Lean.MessageData) : m Unit</code><span class="sep"></span><code class="docstring">Log a new information message using the given message data. The position is provided by `ref`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9729">t<span class="hover-container"><span class="hover-info"><code>Lean.TSyntax `term</code></span></span></span> <span class="keyword token" data-binding="kw-occ-Lean.termM!_-3217">m!</span><span class="unknown token" data-binding="">"Hello! ({</span><span class="var token" data-binding="var-_uniq.9864">i<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span><span class="unknown token" data-binding="">})"</span>
  <span class="const token" data-binding="const-Lean.logInfoAt">logInfoAt<span class="hover-container"><span class="hover-info"><code>Lean.logInfoAt {m : Type → Type} [Monad m] [Lean.MonadLog m] [Lean.AddMessageContext m] [Lean.MonadOptions m]
  (ref : Lean.Syntax) (msgData : Lean.MessageData) : m Unit</code><span class="sep"></span><code class="docstring">Log a new information message using the given message data. The position is provided by `ref`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.9729">t<span class="hover-container"><span class="hover-info"><code>Lean.TSyntax `term</code></span></span></span> <span class="literal string token" data-binding="">"Some multi-line\ninfo too"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"Some multi-line\ninfo too"</span> : String</code></span></span></span>
  <span class="const token" data-binding="const-Lean.Elab.Term.elabTerm">elabTerm<span class="hover-container"><span class="hover-info"><code>Lean.Elab.Term.elabTerm (stx : Lean.Syntax) (expectedType? : Option Lean.Expr)
  (catchExPostpone implicitLambda : Bool := true) : Lean.Elab.TermElabM Lean.Expr</code><span class="sep"></span><code class="docstring">Main function for elaborating terms.
It extracts the elaboration methods from the environment using the node kind.
Recall that the environment has a mapping from `SyntaxNodeKind` to `TermElab` methods.
It creates a fresh macro scope for executing the elaboration method.
All unlogged trace messages produced by the elaboration method are logged using
the position information at `stx`. If the elaboration method throws an `Exception.error` and `errToSorry == true`,
the error is logged and a synthetic sorry expression is returned.
If the elaboration throws `Exception.postpone` and `catchExPostpone == true`,
a new synthetic metavariable of kind `SyntheticMVarKind.postponed` is created, registered,
and returned.
The option `catchExPostpone == false` is used to implement `resumeElabTerm`
to prevent the creation of another synthetic metavariable when resuming the elaboration.

If `implicitLambda == false`, then disable implicit lambdas feature for the given syntax, but not for its subterms.
We use this flag to implement, for example, the `@` modifier. If `Context.implicitLambda == false`, then this parameter has no effect.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.9729">t<span class="hover-container"><span class="hover-info"><code>Lean.TSyntax `term</code></span></span></span> <span class="const token" data-binding="const-Option.none">none<span class="hover-container"><span class="hover-info"><code>Option.none.{u} {α : Type u} : Option α</code><span class="sep"></span><code class="docstring">No value. </code></span></span></span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-3295">elab</span> <span class="literal string token" data-binding="">"%more_info("<span class="hover-container"><span class="hover-info"><code><span class="literal string">"%more_info("</span> : String</code></span></span></span> <span class="var token" data-binding="var-_uniq.10850">t<span class="hover-container"><span class="hover-info"><code>Lean.TSyntax `term</code></span></span></span><span class="unknown token" data-binding="">:</span><span class="const token" data-binding="const-Lean.Parser.Category.term">term<span class="hover-container"><span class="hover-info"><code>Lean.Parser.Category.term : Lean.Parser.Category</code><span class="sep"></span><code class="docstring">`term` is the builtin syntax category for terms. A term denotes an expression
in lean's type theory, for example `2 + 2` is a term. The difference between
`Term` and `Expr` is that the former is a kind of syntax, while the latter is
the result of elaboration. For example `by simp` is also a `Term`, but it elaborates
to different `Expr`s depending on the context. </code></span></span></span> <span class="literal string token" data-binding="">")"<span class="hover-container"><span class="hover-info"><code><span class="literal string">")"</span> : String</code></span></span></span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.term">term<span class="hover-container"><span class="hover-info"><code>Lean.Parser.Category.term : Lean.Parser.Category</code><span class="sep"></span><code class="docstring">`term` is the builtin syntax category for terms. A term denotes an expression
in lean's type theory, for example `2 + 2` is a term. The difference between
`Term` and `Expr` is that the former is a kind of syntax, while the latter is
the result of elaboration. For example `by simp` is also a `Term`, but it elaborates
to different `Expr`s depending on the context. </code></span></span></span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.open-3335">open<span class="hover-container"><span class="hover-info"><code class="docstring">`open Foo in e` is like `open Foo` but scoped to a single term.
It makes the given namespaces available in the term `e`.
</code></span></span></span> <span class="unknown token" data-binding="">Lean</span> <span class="unknown token" data-binding="">Elab</span> <span class="unknown token" data-binding="">Term</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.open-3335">in<span class="hover-container"><span class="hover-info"><code class="docstring">`open Foo in e` is like `open Foo` but scoped to a single term.
It makes the given namespaces available in the term `e`.
</code></span></span></span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-3358">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-3363">for<span class="hover-container"><span class="hover-info"><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.10985">i<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-3367">in</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">0</span><span class="unknown token" data-binding="">:</span><span class="unknown token" data-binding="">20</span><span class="unknown token" data-binding="">]</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-3363">do<span class="hover-container"><span class="hover-info"><code class="docstring">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.
`break` and `continue` are supported inside `for` loops.
`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,
until at least one of them is exhausted.
The types of `e2` etc. must implement the `ToStream` typeclass.
</code></span></span></span>
    <span class="const token" data-binding="const-Lean.logInfoAt">logInfoAt<span class="hover-container"><span class="hover-info"><code>Lean.logInfoAt {m : Type → Type} [Monad m] [Lean.MonadLog m] [Lean.AddMessageContext m] [Lean.MonadOptions m]
  (ref : Lean.Syntax) (msgData : Lean.MessageData) : m Unit</code><span class="sep"></span><code class="docstring">Log a new information message using the given message data. The position is provided by `ref`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.10850">t<span class="hover-container"><span class="hover-info"><code>Lean.TSyntax `term</code></span></span></span> <span class="keyword token" data-binding="kw-occ-Lean.termM!_-3398">m!</span><span class="unknown token" data-binding="">"Hello again! ({</span><span class="var token" data-binding="var-_uniq.10985">i<span class="hover-container"><span class="hover-info"><code>Nat</code></span></span></span><span class="unknown token" data-binding="">})"</span>
  <span class="const token" data-binding="const-Lean.logErrorAt">logErrorAt<span class="hover-container"><span class="hover-info"><code>Lean.logErrorAt {m : Type → Type} [Monad m] [Lean.MonadLog m] [Lean.AddMessageContext m] [Lean.MonadOptions m]
  (ref : Lean.Syntax) (msgData : Lean.MessageData) : m Unit</code><span class="sep"></span><code class="docstring">Log a new error message using the given message data. The position is provided by `ref`. </code></span></span></span> <span class="var token" data-binding="var-_uniq.10850">t<span class="hover-container"><span class="hover-info"><code>Lean.TSyntax `term</code></span></span></span> <span class="literal string token" data-binding="">"And a great big error, much wider than the other info!"<span class="hover-container"><span class="hover-info"><code><span class="literal string">"And a great big error, much wider than the other info!"</span> : String</code></span></span></span>
  <span class="const token" data-binding="const-Lean.Elab.Term.elabTerm">elabTerm<span class="hover-container"><span class="hover-info"><code>Lean.Elab.Term.elabTerm (stx : Lean.Syntax) (expectedType? : Option Lean.Expr)
  (catchExPostpone implicitLambda : Bool := true) : Lean.Elab.TermElabM Lean.Expr</code><span class="sep"></span><code class="docstring">Main function for elaborating terms.
It extracts the elaboration methods from the environment using the node kind.
Recall that the environment has a mapping from `SyntaxNodeKind` to `TermElab` methods.
It creates a fresh macro scope for executing the elaboration method.
All unlogged trace messages produced by the elaboration method are logged using
the position information at `stx`. If the elaboration method throws an `Exception.error` and `errToSorry == true`,
the error is logged and a synthetic sorry expression is returned.
If the elaboration throws `Exception.postpone` and `catchExPostpone == true`,
a new synthetic metavariable of kind `SyntheticMVarKind.postponed` is created, registered,
and returned.
The option `catchExPostpone == false` is used to implement `resumeElabTerm`
to prevent the creation of another synthetic metavariable when resuming the elaboration.

If `implicitLambda == false`, then disable implicit lambdas feature for the given syntax, but not for its subterms.
We use this flag to implement, for example, the `@` modifier. If `Context.implicitLambda == false`, then this parameter has no effect.
</code></span></span></span> <span class="var token" data-binding="var-_uniq.10850">t<span class="hover-container"><span class="hover-info"><code>Lean.TSyntax `term</code></span></span></span> <span class="const token" data-binding="const-Option.none">none<span class="hover-container"><span class="hover-info"><code>Option.none.{u} {α : Type u} : Option α</code><span class="sep"></span><code class="docstring">No value. </code></span></span></span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="demo"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-3542">example</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">%much_info(</span><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Some multi-line
info too</code><code class="message info">Hello! (0)</code><code class="message info">Hello! (1)</code><code class="message info">Hello! (2)</code><code class="message info">Hello! (3)</code><code class="message info">Hello! (4)</code><code class="message info">Hello! (5)</code><code class="message info">Hello! (6)</code><code class="message info">Hello! (7)</code><code class="message info">Hello! (8)</code><code class="message info">Hello! (9)</code><code class="message info">Hello! (10)</code><code class="message info">Hello! (11)</code><code class="message info">Hello! (12)</code><code class="message info">Hello! (13)</code><code class="message info">Hello! (14)</code><code class="message info">Hello! (15)</code><code class="message info">Hello! (16)</code><code class="message info">Hello! (17)</code><code class="message info">Hello! (18)</code><code class="message info">Hello! (19)</code></span></span><span class="unknown token" data-binding="">22</span></span><span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-3569">example</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">%more_info(</span><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">And a great big error, much wider than the other info!</code><code class="message info">Hello again! (0)</code><code class="message info">Hello again! (1)</code><code class="message info">Hello again! (2)</code><code class="message info">Hello again! (3)</code><code class="message info">Hello again! (4)</code><code class="message info">Hello again! (5)</code><code class="message info">Hello again! (6)</code><code class="message info">Hello again! (7)</code><code class="message info">Hello again! (8)</code><code class="message info">Hello again! (9)</code><code class="message info">Hello again! (10)</code><code class="message info">Hello again! (11)</code><code class="message info">Hello again! (12)</code><code class="message info">Hello again! (13)</code><code class="message info">Hello again! (14)</code><code class="message info">Hello again! (15)</code><code class="message info">Hello again! (16)</code><code class="message info">Hello again! (17)</code><code class="message info">Hello again! (18)</code><code class="message info">Hello again! (19)</code></span></span><span class="unknown token" data-binding="">25</span></span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
          The info gets stacked up, with the greatest severity highlighting the range in question.</p>
        <p>
          Thank you for looking at my test/demo post.
</p>
        </div>
      </div>
    </body>
  </html>

